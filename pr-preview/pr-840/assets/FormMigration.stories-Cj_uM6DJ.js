import{j as f}from"./iframe-L2WfQCwc.js";import{p as C,t as Je}from"./index-CJEHracG.js";import{g as J,s as W,b as Xe,u as Ae,F as Ee}from"./index.esm-mgJWN3o1.js";import{L as Re}from"./index-Dn592ewG.js";import{C as je,a as De,b as Pe,c as Ne}from"./index-CpOaWkkB.js";import{k as Le,i as z,j as M}from"./index-CzXABN3m.js";import{T as ae}from"./index-BkC-Zfxo.js";import"./preload-helper-Dp1pzeXC.js";import"./Tooltip-BMsQv-ox.js";import"./useTheme-X_Qa8Dhp.js";import"./styled-BnTbP4z1.js";import"./memoTheme-DbVnS5NV.js";import"./useSlot-DIvU7LRB.js";import"./mergeSlotProps-DHVHFrS4.js";import"./isHostComponent-DVu5iVWx.js";import"./useForkRef-C3tscFOR.js";import"./generateUtilityClasses-DDbjFgb8.js";import"./generateUtilityClass-BtcU_pBl.js";import"./useTimeout-CpICOsEx.js";import"./useControlled-BwGYVh51.js";import"./useEventCallback-CrctvfCx.js";import"./getReactElementRef-BWc-HwFQ.js";import"./Portal-B8Bei1bh.js";import"./utils-B5nq23mn.js";import"./TransitionGroupContext-yrVXEs3b.js";import"./ownerDocument-DW-IO8s5.js";import"./useSlotProps-B_VhlgSD.js";import"./isFocusVisible-B8k4qzLc.js";import"./IconButton-BicFpcJT.js";import"./createSimplePaletteValueFilter-bm0fmN_7.js";import"./ButtonBase-DCYuzXhR.js";import"./CircularProgress-B0WBDXJs.js";import"./Button-B1u8B3-l.js";import"./index-sG74fZmC.js";import"./index-DZMUvtd-.js";import"./index-DcPcEC4T.js";import"./___vite-browser-external_commonjs-proxy-BGdEQkiI.js";import"./index-DuRQpI0H.js";import"./_toKey-DuWRNRhf.js";import"./Autocomplete-CGFgs562.js";import"./Select-DjLfknxE.js";import"./Menu-D7peMxM5.js";import"./Popover-B7G6K2kq.js";import"./ownerWindow-HkKU3E4x.js";import"./debounce-Be36O1Ab.js";import"./mergeSlotProps-CWoOrWbD.js";import"./Modal-D5Qdog5s.js";import"./createChainedFunction-BO_9K8Jh.js";import"./Backdrop-D7wf_uck.js";import"./Fade-CQS6r_wU.js";import"./Paper-BGi8TE6x.js";import"./List-D2he6eDF.js";import"./utils-DoM3o7-Q.js";import"./formControlState-Dq1zat_P.js";import"./useFormControl-DN-RqkfH.js";import"./createSvgIcon-CN7Wy4aL.js";import"./SvgIcon-B1vwUV3N.js";import"./OutlinedInput-CWyWBPMD.js";import"./Close-DRgRl-Mx.js";import"./usePreviousProps-D5NhxkXt.js";import"./Chip-DFrJ2Eby.js";import"./ListSubheader-D6dnP-SY.js";import"./useInfiniteQuery-BAbKH8Ci.js";import"./useBaseQuery-B79-Ponu.js";import"./suspense-DRSFrig5.js";import"./infiniteQueryBehavior-B_QQvG9O.js";import"./index-CiKBxIjV.js";import"./index-CSnqgGqw.js";import"./faCircleArrowRight-B87giHcC.js";import"./faUser-meEUFR5-.js";import"./DatePicker-PhR0CcTS.js";import"./index-fYDJbISR.js";import"./index-Chjiymov.js";import"./Typography-caGtC1xp.js";import"./TextField-BFXId2wL.js";import"./FormLabel-8xWJV5Dj.js";import"./FormHelperText-CamvAlEY.js";import"./FormControl-BmLki1qW.js";import"./isMuiElement-SRHHNfX0.js";import"./visuallyHidden-Dan1xhjv.js";import"./InputAdornment-VfoQToxB.js";import"./DialogActions-B5X4qc64.js";import"./ListItem-9cHvvtWV.js";import"./Dialog-BFN7L2K8.js";import"./DialogContext-nEs_5IUG.js";import"./DialogContent-tFAn31Or.js";import"./dialogTitleClasses-Df1yqyCK.js";import"./index-DJKl12U0.js";import"./index-jgvtu0vB.js";import"./Box-CX0N0ctd.js";import"./Grid-B587iyjg.js";import"./styled-cdoMrI2T.js";import"./Stack-BhxFzEo9.js";import"./Container-0A1GRnLt.js";import"./faCheck-BUdkY9Qv.js";import"./FormControlLabel-mvG_upvO.js";import"./Switch-kUKw20MM.js";import"./SwitchBase-CQdZnqs0.js";import"./RadioGroup-C2RdLrrk.js";import"./Radio-36twfGTs.js";import"./FormGroup-D2CPtvpg.js";import"./Divider-B5nuI06r.js";import"./dividerClasses-CxQzuCbE.js";var H,le;function Qe(){if(le)return H;le=1;const i=/[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g,e=u=>u.match(i)||[],t=u=>u[0].toUpperCase()+u.slice(1),r=(u,c)=>e(u).join(c).toLowerCase(),n=u=>e(u).reduce((c,m)=>`${c}${c?m[0].toUpperCase()+m.slice(1).toLowerCase():m.toLowerCase()}`,"");return H={words:e,upperFirst:t,camelCase:n,pascalCase:u=>t(n(u)),snakeCase:u=>r(u,"_"),kebabCase:u=>r(u,"-"),sentenceCase:u=>t(r(u," ")),titleCase:u=>e(u).map(t).join(" ")},H}var Y=Qe();const et=Object.prototype.toString,tt=Error.prototype.toString,rt=RegExp.prototype.toString,nt=typeof Symbol<"u"?Symbol.prototype.toString:()=>"",it=/^Symbol\((.*)\)(.*)$/;function ot(i){return i!=+i?"NaN":i===0&&1/i<0?"-0":""+i}function ue(i,e=!1){if(i==null||i===!0||i===!1)return""+i;const t=typeof i;if(t==="number")return ot(i);if(t==="string")return e?`"${i}"`:i;if(t==="function")return"[Function "+(i.name||"anonymous")+"]";if(t==="symbol")return nt.call(i).replace(it,"Symbol($1)");const r=et.call(i).slice(8,-1);return r==="Date"?isNaN(i.getTime())?""+i:i.toISOString(i):r==="Error"||i instanceof Error?"["+tt.call(i)+"]":r==="RegExp"?rt.call(i):null}function S(i,e){let t=ue(i,e);return t!==null?t:JSON.stringify(i,function(r,n){let o=ue(this[r],e);return o!==null?o:n},2)}function Ve(i){return i==null?[]:[].concat(i)}let Ie,ze,Me,st=/\$\{\s*(\w+)\s*\}/g;Ie=Symbol.toStringTag;class de{constructor(e,t,r,n){this.name=void 0,this.message=void 0,this.value=void 0,this.path=void 0,this.type=void 0,this.params=void 0,this.errors=void 0,this.inner=void 0,this[Ie]="Error",this.name="ValidationError",this.value=t,this.path=r,this.type=n,this.errors=[],this.inner=[],Ve(e).forEach(o=>{if(b.isError(o)){this.errors.push(...o.errors);const s=o.inner.length?o.inner:[o];this.inner.push(...s)}else this.errors.push(o)}),this.message=this.errors.length>1?`${this.errors.length} errors occurred`:this.errors[0]}}ze=Symbol.hasInstance;Me=Symbol.toStringTag;class b extends Error{static formatError(e,t){const r=t.label||t.path||"this";return t=Object.assign({},t,{path:r,originalPath:t.path}),typeof e=="string"?e.replace(st,(n,o)=>S(t[o])):typeof e=="function"?e(t):e}static isError(e){return e&&e.name==="ValidationError"}constructor(e,t,r,n,o){const s=new de(e,t,r,n);if(o)return s;super(),this.value=void 0,this.path=void 0,this.type=void 0,this.params=void 0,this.errors=[],this.inner=[],this[Me]="Error",this.name=s.name,this.message=s.message,this.type=s.type,this.value=s.value,this.path=s.path,this.errors=s.errors,this.inner=s.inner,Error.captureStackTrace&&Error.captureStackTrace(this,b)}static[ze](e){return de[Symbol.hasInstance](e)||super[Symbol.hasInstance](e)}}let F={default:"${path} is invalid",required:"${path} is a required field",defined:"${path} must be defined",notNull:"${path} cannot be null",oneOf:"${path} must be one of the following values: ${values}",notOneOf:"${path} must not be one of the following values: ${values}",notType:({path:i,type:e,value:t,originalValue:r})=>{const n=r!=null&&r!==t?` (cast from the value \`${S(r,!0)}\`).`:".";return e!=="mixed"?`${i} must be a \`${e}\` type, but the final value was: \`${S(t,!0)}\``+n:`${i} must match the configured type. The validated value was: \`${S(t,!0)}\``+n}},h={length:"${path} must be exactly ${length} characters",min:"${path} must be at least ${min} characters",max:"${path} must be at most ${max} characters",matches:'${path} must match the following: "${regex}"',email:"${path} must be a valid email",url:"${path} must be a valid URL",uuid:"${path} must be a valid UUID",datetime:"${path} must be a valid ISO date-time",datetime_precision:"${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits",datetime_offset:'${path} must be a valid ISO date-time with UTC "Z" timezone',trim:"${path} must be a trimmed string",lowercase:"${path} must be a lowercase string",uppercase:"${path} must be a upper case string"},at={min:"${path} must be greater than or equal to ${min}",max:"${path} must be less than or equal to ${max}",lessThan:"${path} must be less than ${less}",moreThan:"${path} must be greater than ${more}",positive:"${path} must be a positive number",negative:"${path} must be a negative number",integer:"${path} must be an integer"},X={min:"${path} field must be later than ${min}",max:"${path} field must be at earlier than ${max}"},lt={isValue:"${path} field must be ${value}"},L={noUnknown:"${path} field has unspecified keys: ${unknown}",exact:"${path} object contains unknown properties: ${properties}"},ut={min:"${path} field must have at least ${min} items",max:"${path} field must have less than or equal to ${max} items",length:"${path} must have ${length} items"},dt={notType:i=>{const{path:e,value:t,spec:r}=i,n=r.types.length;if(Array.isArray(t)){if(t.length<n)return`${e} tuple value has too few items, expected a length of ${n} but got ${t.length} for value: \`${S(t,!0)}\``;if(t.length>n)return`${e} tuple value has too many items, expected a length of ${n} but got ${t.length} for value: \`${S(t,!0)}\``}return b.formatError(F.notType,i)}};Object.assign(Object.create(null),{mixed:F,string:h,number:at,date:X,object:L,array:ut,boolean:lt,tuple:dt});const ee=i=>i&&i.__isYupSchema__;class B{static fromOptions(e,t){if(!t.then&&!t.otherwise)throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");let{is:r,then:n,otherwise:o}=t,s=typeof r=="function"?r:(...a)=>a.every(l=>l===r);return new B(e,(a,l)=>{var d;let u=s(...a)?n:o;return(d=u==null?void 0:u(l))!=null?d:l})}constructor(e,t){this.fn=void 0,this.refs=e,this.refs=e,this.fn=t}resolve(e,t){let r=this.refs.map(o=>o.getValue(t==null?void 0:t.value,t==null?void 0:t.parent,t==null?void 0:t.context)),n=this.fn(r,e,t);if(n===void 0||n===e)return e;if(!ee(n))throw new TypeError("conditions must return a schema object");return n.resolve(t)}}const N={context:"$",value:"."};class ${constructor(e,t={}){if(this.key=void 0,this.isContext=void 0,this.isValue=void 0,this.isSibling=void 0,this.path=void 0,this.getter=void 0,this.map=void 0,typeof e!="string")throw new TypeError("ref must be a string, got: "+e);if(this.key=e.trim(),e==="")throw new TypeError("ref must be a non-empty string");this.isContext=this.key[0]===N.context,this.isValue=this.key[0]===N.value,this.isSibling=!this.isContext&&!this.isValue;let r=this.isContext?N.context:this.isValue?N.value:"";this.path=this.key.slice(r.length),this.getter=this.path&&C.getter(this.path,!0),this.map=t.map}getValue(e,t,r){let n=this.isContext?r:this.isValue?e:t;return this.getter&&(n=this.getter(n||{})),this.map&&(n=this.map(n)),n}cast(e,t){return this.getValue(e,t==null?void 0:t.parent,t==null?void 0:t.context)}resolve(){return this}describe(){return{type:"ref",key:this.key}}toString(){return`Ref(${this.key})`}static isRef(e){return e&&e.__isYupRef}}$.prototype.__isYupRef=!0;const O=i=>i==null;function q(i){function e({value:t,path:r="",options:n,originalValue:o,schema:s},a,l){const{name:d,test:u,params:c,message:m,skipAbsent:g}=i;let{parent:k,context:x,abortEarly:w=s.spec.abortEarly,disableStackTrace:D=s.spec.disableStackTrace}=n;function T(p){return $.isRef(p)?p.getValue(t,k,x):p}function re(p={}){const _=Object.assign({value:t,originalValue:o,label:s.spec.label,path:p.path||r,spec:s.spec,disableStackTrace:p.disableStackTrace||D},c,p.params);for(const se of Object.keys(_))_[se]=T(_[se]);const oe=new b(b.formatError(p.message||m,_),t,_.path,p.type||d,_.disableStackTrace);return oe.params=_,oe}const U=w?a:l;let Z={path:r,parent:k,type:d,from:n.from,createError:re,resolve:T,options:n,originalValue:o,schema:s};const K=p=>{b.isError(p)?U(p):p?l(null):U(re())},ne=p=>{b.isError(p)?U(p):a(p)};if(g&&O(t))return K(!0);let P;try{var ie;if(P=u.call(Z,t,Z),typeof((ie=P)==null?void 0:ie.then)=="function"){if(n.sync)throw new Error(`Validation test of type: "${Z.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);return Promise.resolve(P).then(K,ne)}}catch(p){ne(p);return}K(P)}return e.OPTIONS=i,e}function ct(i,e,t,r=t){let n,o,s;return e?(C.forEach(e,(a,l,d)=>{let u=l?a.slice(1,a.length-1):a;i=i.resolve({context:r,parent:n,value:t});let c=i.type==="tuple",m=d?parseInt(u,10):0;if(i.innerType||c){if(c&&!d)throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${s}" must contain an index to the tuple element, e.g. "${s}[0]"`);if(t&&m>=t.length)throw new Error(`Yup.reach cannot resolve an array item at index: ${a}, in the path: ${e}. because there is no value at that index. `);n=t,t=t&&t[m],i=c?i.spec.types[m]:i.innerType}if(!d){if(!i.fields||!i.fields[u])throw new Error(`The schema does not contain the path: ${e}. (failed at: ${s} which is a type: "${i.type}")`);n=t,t=t&&t[u],i=i.fields[u]}o=u,s=l?"["+a+"]":"."+a}),{schema:i,parent:n,parentPath:o}):{parent:n,parentPath:e,schema:i}}class G extends Set{describe(){const e=[];for(const t of this.values())e.push($.isRef(t)?t.describe():t);return e}resolveAll(e){let t=[];for(const r of this.values())t.push(e(r));return t}clone(){return new G(this.values())}merge(e,t){const r=this.clone();return e.forEach(n=>r.add(n)),t.forEach(n=>r.delete(n)),r}}function A(i,e=new Map){if(ee(i)||!i||typeof i!="object")return i;if(e.has(i))return e.get(i);let t;if(i instanceof Date)t=new Date(i.getTime()),e.set(i,t);else if(i instanceof RegExp)t=new RegExp(i),e.set(i,t);else if(Array.isArray(i)){t=new Array(i.length),e.set(i,t);for(let r=0;r<i.length;r++)t[r]=A(i[r],e)}else if(i instanceof Map){t=new Map,e.set(i,t);for(const[r,n]of i.entries())t.set(r,A(n,e))}else if(i instanceof Set){t=new Set,e.set(i,t);for(const r of i)t.add(A(r,e))}else if(i instanceof Object){t={},e.set(i,t);for(const[r,n]of Object.entries(i))t[r]=A(n,e)}else throw Error(`Unable to clone ${i}`);return t}class y{constructor(e){this.type=void 0,this.deps=[],this.tests=void 0,this.transforms=void 0,this.conditions=[],this._mutate=void 0,this.internalTests={},this._whitelist=new G,this._blacklist=new G,this.exclusiveTests=Object.create(null),this._typeCheck=void 0,this.spec=void 0,this.tests=[],this.transforms=[],this.withMutation(()=>{this.typeError(F.notType)}),this.type=e.type,this._typeCheck=e.check,this.spec=Object.assign({strip:!1,strict:!1,abortEarly:!0,recursive:!0,disableStackTrace:!1,nullable:!1,optional:!0,coerce:!0},e==null?void 0:e.spec),this.withMutation(t=>{t.nonNullable()})}get _type(){return this.type}clone(e){if(this._mutate)return e&&Object.assign(this.spec,e),this;const t=Object.create(Object.getPrototypeOf(this));return t.type=this.type,t._typeCheck=this._typeCheck,t._whitelist=this._whitelist.clone(),t._blacklist=this._blacklist.clone(),t.internalTests=Object.assign({},this.internalTests),t.exclusiveTests=Object.assign({},this.exclusiveTests),t.deps=[...this.deps],t.conditions=[...this.conditions],t.tests=[...this.tests],t.transforms=[...this.transforms],t.spec=A(Object.assign({},this.spec,e)),t}label(e){let t=this.clone();return t.spec.label=e,t}meta(...e){if(e.length===0)return this.spec.meta;let t=this.clone();return t.spec.meta=Object.assign(t.spec.meta||{},e[0]),t}withMutation(e){let t=this._mutate;this._mutate=!0;let r=e(this);return this._mutate=t,r}concat(e){if(!e||e===this)return this;if(e.type!==this.type&&this.type!=="mixed")throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${e.type}`);let t=this,r=e.clone();const n=Object.assign({},t.spec,r.spec);return r.spec=n,r.internalTests=Object.assign({},t.internalTests,r.internalTests),r._whitelist=t._whitelist.merge(e._whitelist,e._blacklist),r._blacklist=t._blacklist.merge(e._blacklist,e._whitelist),r.tests=t.tests,r.exclusiveTests=t.exclusiveTests,r.withMutation(o=>{e.tests.forEach(s=>{o.test(s.OPTIONS)})}),r.transforms=[...t.transforms,...r.transforms],r}isType(e){return e==null?!!(this.spec.nullable&&e===null||this.spec.optional&&e===void 0):this._typeCheck(e)}resolve(e){let t=this;if(t.conditions.length){let r=t.conditions;t=t.clone(),t.conditions=[],t=r.reduce((n,o)=>o.resolve(n,e),t),t=t.resolve(e)}return t}resolveOptions(e){var t,r,n,o;return Object.assign({},e,{from:e.from||[],strict:(t=e.strict)!=null?t:this.spec.strict,abortEarly:(r=e.abortEarly)!=null?r:this.spec.abortEarly,recursive:(n=e.recursive)!=null?n:this.spec.recursive,disableStackTrace:(o=e.disableStackTrace)!=null?o:this.spec.disableStackTrace})}cast(e,t={}){let r=this.resolve(Object.assign({value:e},t)),n=t.assert==="ignore-optionality",o=r._cast(e,t);if(t.assert!==!1&&!r.isType(o)){if(n&&O(o))return o;let s=S(e),a=S(o);throw new TypeError(`The value of ${t.path||"field"} could not be cast to a value that satisfies the schema type: "${r.type}". 

attempted value: ${s} 
`+(a!==s?`result of cast: ${a}`:""))}return o}_cast(e,t){let r=e===void 0?e:this.transforms.reduce((n,o)=>o.call(this,n,e,this),e);return r===void 0&&(r=this.getDefault(t)),r}_validate(e,t={},r,n){let{path:o,originalValue:s=e,strict:a=this.spec.strict}=t,l=e;a||(l=this._cast(l,Object.assign({assert:!1},t)));let d=[];for(let u of Object.values(this.internalTests))u&&d.push(u);this.runTests({path:o,value:l,originalValue:s,options:t,tests:d},r,u=>{if(u.length)return n(u,l);this.runTests({path:o,value:l,originalValue:s,options:t,tests:this.tests},r,n)})}runTests(e,t,r){let n=!1,{tests:o,value:s,originalValue:a,path:l,options:d}=e,u=x=>{n||(n=!0,t(x,s))},c=x=>{n||(n=!0,r(x,s))},m=o.length,g=[];if(!m)return c([]);let k={value:s,originalValue:a,path:l,options:d,schema:this};for(let x=0;x<o.length;x++){const w=o[x];w(k,u,function(T){T&&(Array.isArray(T)?g.push(...T):g.push(T)),--m<=0&&c(g)})}}asNestedTest({key:e,index:t,parent:r,parentPath:n,originalParent:o,options:s}){const a=e??t;if(a==null)throw TypeError("Must include `key` or `index` for nested validations");const l=typeof a=="number";let d=r[a];const u=Object.assign({},s,{strict:!0,parent:r,value:d,originalValue:o[a],key:void 0,[l?"index":"key"]:a,path:l||a.includes(".")?`${n||""}[${l?a:`"${a}"`}]`:(n?`${n}.`:"")+e});return(c,m,g)=>this.resolve(u)._validate(d,u,m,g)}validate(e,t){var r;let n=this.resolve(Object.assign({},t,{value:e})),o=(r=t==null?void 0:t.disableStackTrace)!=null?r:n.spec.disableStackTrace;return new Promise((s,a)=>n._validate(e,t,(l,d)=>{b.isError(l)&&(l.value=d),a(l)},(l,d)=>{l.length?a(new b(l,d,void 0,void 0,o)):s(d)}))}validateSync(e,t){var r;let n=this.resolve(Object.assign({},t,{value:e})),o,s=(r=t==null?void 0:t.disableStackTrace)!=null?r:n.spec.disableStackTrace;return n._validate(e,Object.assign({},t,{sync:!0}),(a,l)=>{throw b.isError(a)&&(a.value=l),a},(a,l)=>{if(a.length)throw new b(a,e,void 0,void 0,s);o=l}),o}isValid(e,t){return this.validate(e,t).then(()=>!0,r=>{if(b.isError(r))return!1;throw r})}isValidSync(e,t){try{return this.validateSync(e,t),!0}catch(r){if(b.isError(r))return!1;throw r}}_getDefault(e){let t=this.spec.default;return t==null?t:typeof t=="function"?t.call(this,e):A(t)}getDefault(e){return this.resolve(e||{})._getDefault(e)}default(e){return arguments.length===0?this._getDefault():this.clone({default:e})}strict(e=!0){return this.clone({strict:e})}nullability(e,t){const r=this.clone({nullable:e});return r.internalTests.nullable=q({message:t,name:"nullable",test(n){return n===null?this.schema.spec.nullable:!0}}),r}optionality(e,t){const r=this.clone({optional:e});return r.internalTests.optionality=q({message:t,name:"optionality",test(n){return n===void 0?this.schema.spec.optional:!0}}),r}optional(){return this.optionality(!0)}defined(e=F.defined){return this.optionality(!1,e)}nullable(){return this.nullability(!0)}nonNullable(e=F.notNull){return this.nullability(!1,e)}required(e=F.required){return this.clone().withMutation(t=>t.nonNullable(e).defined(e))}notRequired(){return this.clone().withMutation(e=>e.nullable().optional())}transform(e){let t=this.clone();return t.transforms.push(e),t}test(...e){let t;if(e.length===1?typeof e[0]=="function"?t={test:e[0]}:t=e[0]:e.length===2?t={name:e[0],test:e[1]}:t={name:e[0],message:e[1],test:e[2]},t.message===void 0&&(t.message=F.default),typeof t.test!="function")throw new TypeError("`test` is a required parameters");let r=this.clone(),n=q(t),o=t.exclusive||t.name&&r.exclusiveTests[t.name]===!0;if(t.exclusive&&!t.name)throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");return t.name&&(r.exclusiveTests[t.name]=!!t.exclusive),r.tests=r.tests.filter(s=>!(s.OPTIONS.name===t.name&&(o||s.OPTIONS.test===n.OPTIONS.test))),r.tests.push(n),r}when(e,t){!Array.isArray(e)&&typeof e!="string"&&(t=e,e=".");let r=this.clone(),n=Ve(e).map(o=>new $(o));return n.forEach(o=>{o.isSibling&&r.deps.push(o.key)}),r.conditions.push(typeof t=="function"?new B(n,t):B.fromOptions(n,t)),r}typeError(e){let t=this.clone();return t.internalTests.typeError=q({message:e,name:"typeError",skipAbsent:!0,test(r){return this.schema._typeCheck(r)?!0:this.createError({params:{type:this.schema.type}})}}),t}oneOf(e,t=F.oneOf){let r=this.clone();return e.forEach(n=>{r._whitelist.add(n),r._blacklist.delete(n)}),r.internalTests.whiteList=q({message:t,name:"oneOf",skipAbsent:!0,test(n){let o=this.schema._whitelist,s=o.resolveAll(this.resolve);return s.includes(n)?!0:this.createError({params:{values:Array.from(o).join(", "),resolved:s}})}}),r}notOneOf(e,t=F.notOneOf){let r=this.clone();return e.forEach(n=>{r._blacklist.add(n),r._whitelist.delete(n)}),r.internalTests.blacklist=q({message:t,name:"notOneOf",test(n){let o=this.schema._blacklist,s=o.resolveAll(this.resolve);return s.includes(n)?this.createError({params:{values:Array.from(o).join(", "),resolved:s}}):!0}}),r}strip(e=!0){let t=this.clone();return t.spec.strip=e,t}describe(e){const t=(e?this.resolve(e):this).clone(),{label:r,meta:n,optional:o,nullable:s}=t.spec;return{meta:n,label:r,optional:o,nullable:s,default:t.getDefault(e),type:t.type,oneOf:t._whitelist.describe(),notOneOf:t._blacklist.describe(),tests:t.tests.map(l=>({name:l.OPTIONS.name,params:l.OPTIONS.params})).filter((l,d,u)=>u.findIndex(c=>c.name===l.name)===d)}}}y.prototype.__isYupSchema__=!0;for(const i of["validate","validateSync"])y.prototype[`${i}At`]=function(e,t,r={}){const{parent:n,parentPath:o,schema:s}=ct(this,e,t,r.context);return s[i](n&&n[o],Object.assign({},r,{parent:n,path:e}))};for(const i of["equals","is"])y.prototype[i]=y.prototype.oneOf;for(const i of["not","nope"])y.prototype[i]=y.prototype.notOneOf;const mt=()=>!0;function Be(i){return new Ge(i)}class Ge extends y{constructor(e){super(typeof e=="function"?{type:"mixed",check:e}:Object.assign({type:"mixed",check:mt},e))}}Be.prototype=Ge.prototype;const ft=/^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;function pt(i){const e=Q(i);if(!e)return Date.parse?Date.parse(i):Number.NaN;if(e.z===void 0&&e.plusMinus===void 0)return new Date(e.year,e.month,e.day,e.hour,e.minute,e.second,e.millisecond).valueOf();let t=0;return e.z!=="Z"&&e.plusMinus!==void 0&&(t=e.hourOffset*60+e.minuteOffset,e.plusMinus==="+"&&(t=0-t)),Date.UTC(e.year,e.month,e.day,e.hour,e.minute+t,e.second,e.millisecond)}function Q(i){var e,t;const r=ft.exec(i);return r?{year:v(r[1]),month:v(r[2],1)-1,day:v(r[3],1),hour:v(r[4]),minute:v(r[5]),second:v(r[6]),millisecond:r[7]?v(r[7].substring(0,3)):0,precision:(e=(t=r[7])==null?void 0:t.length)!=null?e:void 0,z:r[8]||void 0,plusMinus:r[9]||void 0,hourOffset:v(r[10]),minuteOffset:v(r[11])}:null}function v(i,e=0){return Number(i)||e}let ht=/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,bt=/^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i,xt=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i,yt="^\\d{4}-\\d{2}-\\d{2}",gt="\\d{2}:\\d{2}:\\d{2}",Ft="(([+-]\\d{2}(:?\\d{2})?)|Z)",vt=new RegExp(`${yt}T${gt}(\\.\\d+)?${Ft}$`),kt=i=>O(i)||i===i.trim(),wt={}.toString();function V(){return new Ue}class Ue extends y{constructor(){super({type:"string",check(e){return e instanceof String&&(e=e.valueOf()),typeof e=="string"}}),this.withMutation(()=>{this.transform((e,t,r)=>{if(!r.spec.coerce||r.isType(e)||Array.isArray(e))return e;const n=e!=null&&e.toString?e.toString():e;return n===wt?e:n})})}required(e){return super.required(e).withMutation(t=>t.test({message:e||F.required,name:"required",skipAbsent:!0,test:r=>!!r.length}))}notRequired(){return super.notRequired().withMutation(e=>(e.tests=e.tests.filter(t=>t.OPTIONS.name!=="required"),e))}length(e,t=h.length){return this.test({message:t,name:"length",exclusive:!0,params:{length:e},skipAbsent:!0,test(r){return r.length===this.resolve(e)}})}min(e,t=h.min){return this.test({message:t,name:"min",exclusive:!0,params:{min:e},skipAbsent:!0,test(r){return r.length>=this.resolve(e)}})}max(e,t=h.max){return this.test({name:"max",exclusive:!0,message:t,params:{max:e},skipAbsent:!0,test(r){return r.length<=this.resolve(e)}})}matches(e,t){let r=!1,n,o;return t&&(typeof t=="object"?{excludeEmptyString:r=!1,message:n,name:o}=t:n=t),this.test({name:o||"matches",message:n||h.matches,params:{regex:e},skipAbsent:!0,test:s=>s===""&&r||s.search(e)!==-1})}email(e=h.email){return this.matches(ht,{name:"email",message:e,excludeEmptyString:!0})}url(e=h.url){return this.matches(bt,{name:"url",message:e,excludeEmptyString:!0})}uuid(e=h.uuid){return this.matches(xt,{name:"uuid",message:e,excludeEmptyString:!1})}datetime(e){let t="",r,n;return e&&(typeof e=="object"?{message:t="",allowOffset:r=!1,precision:n=void 0}=e:t=e),this.matches(vt,{name:"datetime",message:t||h.datetime,excludeEmptyString:!0}).test({name:"datetime_offset",message:t||h.datetime_offset,params:{allowOffset:r},skipAbsent:!0,test:o=>{if(!o||r)return!0;const s=Q(o);return s?!!s.z:!1}}).test({name:"datetime_precision",message:t||h.datetime_precision,params:{precision:n},skipAbsent:!0,test:o=>{if(!o||n==null)return!0;const s=Q(o);return s?s.precision===n:!1}})}ensure(){return this.default("").transform(e=>e===null?"":e)}trim(e=h.trim){return this.transform(t=>t!=null?t.trim():t).test({message:e,name:"trim",test:kt})}lowercase(e=h.lowercase){return this.transform(t=>O(t)?t:t.toLowerCase()).test({message:e,name:"string_case",exclusive:!0,skipAbsent:!0,test:t=>O(t)||t===t.toLowerCase()})}uppercase(e=h.uppercase){return this.transform(t=>O(t)?t:t.toUpperCase()).test({message:e,name:"string_case",exclusive:!0,skipAbsent:!0,test:t=>O(t)||t===t.toUpperCase()})}}V.prototype=Ue.prototype;let St=new Date(""),Tt=i=>Object.prototype.toString.call(i)==="[object Date]";class te extends y{constructor(){super({type:"date",check(e){return Tt(e)&&!isNaN(e.getTime())}}),this.withMutation(()=>{this.transform((e,t,r)=>!r.spec.coerce||r.isType(e)||e===null?e:(e=pt(e),isNaN(e)?te.INVALID_DATE:new Date(e)))})}prepareParam(e,t){let r;if($.isRef(e))r=e;else{let n=this.cast(e);if(!this._typeCheck(n))throw new TypeError(`\`${t}\` must be a Date or a value that can be \`cast()\` to a Date`);r=n}return r}min(e,t=X.min){let r=this.prepareParam(e,"min");return this.test({message:t,name:"min",exclusive:!0,params:{min:e},skipAbsent:!0,test(n){return n>=this.resolve(r)}})}max(e,t=X.max){let r=this.prepareParam(e,"max");return this.test({message:t,name:"max",exclusive:!0,params:{max:e},skipAbsent:!0,test(n){return n<=this.resolve(r)}})}}te.INVALID_DATE=St;function _t(i,e=[]){let t=[],r=new Set,n=new Set(e.map(([s,a])=>`${s}-${a}`));function o(s,a){let l=C.split(s)[0];r.add(l),n.has(`${a}-${l}`)||t.push([a,l])}for(const s of Object.keys(i)){let a=i[s];r.add(s),$.isRef(a)&&a.isSibling?o(a.path,s):ee(a)&&"deps"in a&&a.deps.forEach(l=>o(l,s))}return Je.array(Array.from(r),t).reverse()}function ce(i,e){let t=1/0;return i.some((r,n)=>{var o;if((o=e.path)!=null&&o.includes(r))return t=n,!0}),t}function Ze(i){return(e,t)=>ce(i,e)-ce(i,t)}const Ot=(i,e,t)=>{if(typeof i!="string")return i;let r=i;try{r=JSON.parse(i)}catch{}return t.isType(r)?r:i};function I(i){if("fields"in i){const e={};for(const[t,r]of Object.entries(i.fields))e[t]=I(r);return i.setFields(e)}if(i.type==="array"){const e=i.optional();return e.innerType&&(e.innerType=I(e.innerType)),e}return i.type==="tuple"?i.optional().clone({types:i.spec.types.map(I)}):"optional"in i?i.optional():i}const Ct=(i,e)=>{const t=[...C.normalizePath(e)];if(t.length===1)return t[0]in i;let r=t.pop(),n=C.getter(C.join(t),!0)(i);return!!(n&&r in n)};let me=i=>Object.prototype.toString.call(i)==="[object Object]";function fe(i,e){let t=Object.keys(i.fields);return Object.keys(e).filter(r=>t.indexOf(r)===-1)}const $t=Ze([]);function Ke(i){return new We(i)}class We extends y{constructor(e){super({type:"object",check(t){return me(t)||typeof t=="function"}}),this.fields=Object.create(null),this._sortErrors=$t,this._nodes=[],this._excludedEdges=[],this.withMutation(()=>{e&&this.shape(e)})}_cast(e,t={}){var r;let n=super._cast(e,t);if(n===void 0)return this.getDefault(t);if(!this._typeCheck(n))return n;let o=this.fields,s=(r=t.stripUnknown)!=null?r:this.spec.noUnknown,a=[].concat(this._nodes,Object.keys(n).filter(c=>!this._nodes.includes(c))),l={},d=Object.assign({},t,{parent:l,__validating:t.__validating||!1}),u=!1;for(const c of a){let m=o[c],g=c in n;if(m){let k,x=n[c];d.path=(t.path?`${t.path}.`:"")+c,m=m.resolve({value:x,context:t.context,parent:l});let w=m instanceof y?m.spec:void 0,D=w==null?void 0:w.strict;if(w!=null&&w.strip){u=u||c in n;continue}k=!t.__validating||!D?m.cast(n[c],d):n[c],k!==void 0&&(l[c]=k)}else g&&!s&&(l[c]=n[c]);(g!==c in l||l[c]!==n[c])&&(u=!0)}return u?l:n}_validate(e,t={},r,n){let{from:o=[],originalValue:s=e,recursive:a=this.spec.recursive}=t;t.from=[{schema:this,value:s},...o],t.__validating=!0,t.originalValue=s,super._validate(e,t,r,(l,d)=>{if(!a||!me(d)){n(l,d);return}s=s||d;let u=[];for(let c of this._nodes){let m=this.fields[c];!m||$.isRef(m)||u.push(m.asNestedTest({options:t,key:c,parent:d,parentPath:t.path,originalParent:s}))}this.runTests({tests:u,value:d,originalValue:s,options:t},r,c=>{n(c.sort(this._sortErrors).concat(l),d)})})}clone(e){const t=super.clone(e);return t.fields=Object.assign({},this.fields),t._nodes=this._nodes,t._excludedEdges=this._excludedEdges,t._sortErrors=this._sortErrors,t}concat(e){let t=super.concat(e),r=t.fields;for(let[n,o]of Object.entries(this.fields)){const s=r[n];r[n]=s===void 0?o:s}return t.withMutation(n=>n.setFields(r,[...this._excludedEdges,...e._excludedEdges]))}_getDefault(e){if("default"in this.spec)return super._getDefault(e);if(!this._nodes.length)return;let t={};return this._nodes.forEach(r=>{var n;const o=this.fields[r];let s=e;(n=s)!=null&&n.value&&(s=Object.assign({},s,{parent:s.value,value:s.value[r]})),t[r]=o&&"getDefault"in o?o.getDefault(s):void 0}),t}setFields(e,t){let r=this.clone();return r.fields=e,r._nodes=_t(e,t),r._sortErrors=Ze(Object.keys(e)),t&&(r._excludedEdges=t),r}shape(e,t=[]){return this.clone().withMutation(r=>{let n=r._excludedEdges;return t.length&&(Array.isArray(t[0])||(t=[t]),n=[...r._excludedEdges,...t]),r.setFields(Object.assign(r.fields,e),n)})}partial(){const e={};for(const[t,r]of Object.entries(this.fields))e[t]="optional"in r&&r.optional instanceof Function?r.optional():r;return this.setFields(e)}deepPartial(){return I(this)}pick(e){const t={};for(const r of e)this.fields[r]&&(t[r]=this.fields[r]);return this.setFields(t,this._excludedEdges.filter(([r,n])=>e.includes(r)&&e.includes(n)))}omit(e){const t=[];for(const r of Object.keys(this.fields))e.includes(r)||t.push(r);return this.pick(t)}from(e,t,r){let n=C.getter(e,!0);return this.transform(o=>{if(!o)return o;let s=o;return Ct(o,e)&&(s=Object.assign({},o),r||delete s[e],s[t]=n(o)),s})}json(){return this.transform(Ot)}exact(e){return this.test({name:"exact",exclusive:!0,message:e||L.exact,test(t){if(t==null)return!0;const r=fe(this.schema,t);return r.length===0||this.createError({params:{properties:r.join(", ")}})}})}stripUnknown(){return this.clone({noUnknown:!0})}noUnknown(e=!0,t=L.noUnknown){typeof e!="boolean"&&(t=e,e=!0);let r=this.test({name:"noUnknown",exclusive:!0,message:t,test(n){if(n==null)return!0;const o=fe(this.schema,n);return!e||o.length===0||this.createError({params:{unknown:o.join(", ")}})}});return r.spec.noUnknown=e,r}unknown(e=!0,t=L.noUnknown){return this.noUnknown(!e,t)}transformKeys(e){return this.transform(t=>{if(!t)return t;const r={};for(const n of Object.keys(t))r[e(n)]=t[n];return r})}camelCase(){return this.transformKeys(Y.camelCase)}snakeCase(){return this.transformKeys(Y.snakeCase)}constantCase(){return this.transformKeys(e=>Y.snakeCase(e).toUpperCase())}describe(e){const t=(e?this.resolve(e):this).clone(),r=super.describe(e);r.fields={};for(const[o,s]of Object.entries(t.fields)){var n;let a=e;(n=a)!=null&&n.value&&(a=Object.assign({},a,{parent:a.value,value:a.value[o]})),r.fields[o]=s.describe(a)}return r}}Ke.prototype=We.prototype;const pe=(i,e,t)=>{if(i&&"reportValidity"in i){const r=J(t,e);i.setCustomValidity(r&&r.message||""),i.reportValidity()}},He=(i,e)=>{for(const t in e.fields){const r=e.fields[t];r&&r.ref&&"reportValidity"in r.ref?pe(r.ref,t,i):r&&r.refs&&r.refs.forEach(n=>pe(n,t,i))}},qt=(i,e)=>{e.shouldUseNativeValidation&&He(i,e);const t={};for(const r in i){const n=J(e.fields,r),o=Object.assign(i[r]||{},{ref:n&&n.ref});if(At(e.names||Object.keys(i),r)){const s=Object.assign({},J(t,r));W(s,"root",o),W(t,r,s)}else W(t,r,o)}return t},At=(i,e)=>{const t=he(e);return i.some(r=>he(r).match(`^${t}\\.\\d+`))};function he(i){return i.replace(/\]|\[/g,"")}function Et(i,e,t){return e===void 0&&(e={}),t===void 0&&(t={}),function(r,n,o){try{return Promise.resolve(function(s,a){try{var l=(e.context,Promise.resolve(i[t.mode==="sync"?"validateSync":"validate"](r,Object.assign({abortEarly:!1},e,{context:n}))).then(function(d){return o.shouldUseNativeValidation&&He({},o),{values:t.raw?Object.assign({},r):d,errors:{}}}))}catch(d){return a(d)}return l&&l.then?l.then(void 0,a):l}(0,function(s){if(!s.inner)throw s;return{values:{},errors:qt((a=s,l=!o.shouldUseNativeValidation&&o.criteriaMode==="all",(a.inner||[]).reduce(function(d,u){if(d[u.path]||(d[u.path]={message:u.message,type:u.type}),l){var c=d[u.path].types,m=c&&c[u.type];d[u.path]=Xe(u.path,l,d,u.type,m?[].concat(m,u.message):u.message)}return d},{})),o)};var a,l}))}catch(s){return Promise.reject(s)}}}const Rt=`There are two main changes made with the form components in \`@availity/element\`:

- Removed \`formik\`
- Updated [usage guidelines](./?path=/docs/bs4-migration-form-migration--disabled-fields)  for \`disabled\` fields and the new \`read-only\` fields

## Why did we remove formik?

The future of \`formik\` is looking questionable - The current major version was released
in 2019 with sparse feature work and dependency updates since.
We were faced with the question of what to replace it with, but also if it
_should_ be replaced at all.

We have chosen the middle ground. We're updating our library of choice for
our controlled components, while also allowing the use of the non-controlled fields. _See the [Form Component Guide](./?path=/docs/form-components-component-guide--docs) for more information on all our form components._

After a successful internal implementation of an extremely long and complicated form using
\`react-hook-form\`, we decided to move forward with it for our controlled form components.

\`react-hook-form\` is very lightweight and flexible. It also boasts a
large community and is actively and regularly supported. \`react-hook-form\`
utilizes it's own internal rules engine for validation, but can be used
with schema-based validation libraries like \`yup\`, \`zod\`, and \`joi\`
when used with the corresponding resolver package. See the
[react-hook-form docs](https://react-hook-form.com/get-started#SchemaValidation)
for more.

We've included examples using only \`react-hook-form\` as well as
using it with \`yup\`+\`@hookform/resolvers/yup\` (don't worry,
\`@hookform/resolvers\` is an official part of \`react-hook-form\`)

## Component Equivalents

| availity-react<br />formik | element<br />react-hook-form | element<br />Not Controlled | Description |
| ---------------------------- | ---------------------------- | --------------------------- | ----------- |
| CheckboxGroup | _N/A_ | _N/A - built with \`FormControl\`, \`FormLabel\`, & \`FormGroup\`_ | Full checkbox group field |
| CurrencyInput | _N/A_ | _N/A - built with \`TextField\` and replacing input. See [Input Masking](./?path=/docs/form-components-textfield-textfield--docs&args=#input-masking)_ | Field with currency input masking |
| DateField | ControlledDatepicker | Datepicker | Date field with picker |
| DateRangeField | _N/A_ | _N/A - see [date range code example](./?path=/docs/form-components-datepicker-datepicker--docs#date-range-picker)_ | Date range field(s) with picker |
| Field | ControlledTextField | TextField | Text input field |
| FieldHelpIcon | _N/A_ | FieldHelpIcon | Availity help topic link |
| FormGroup | _N/A_ | FormControl | Context wrapper for a field. Syncs state, i.e. error, required, disabled, focused, etc |
| Input | _N/A_ | Input | Bare input |
| Label | _N/A_ | FormLabel<br />FormControlLabel | Label for input/group |
| Phone | _N/A_ | _N/A - built with \`TextField\` and replacing input. See [Input Masking](./?path=/docs/form-components-textfield-textfield--docs&args=#input-masking)_ | Field with phone masking |
| RadioGroup | ControlledRadioGroup | _N/A - built with \`FormControl\`, \`FormLabel\`, & \`RadioGroup\`_ | Full radio group field |
| SelectField | ControlledAutocomplete | Autocomplete | Select field with autocompletion |
| ResourceSelect | ControlledAsyncAutocomplete | AsyncAutocomplete | Select field with loader while loading options |
| AvCodeSelect | ControlledCodesAutocomplete | CodesAutocomplete | Specialized autocomplete with codes |
| AvNavigationSelect | _N/A_ | _N/A_ | |
| AvOrganizationSelect | ControlledOrganizationAutocomplete | OrganizationAutocomplete | Specialized autocomplete for organizations |
| AvPayerSelect | _N/A_ | _N/A_ | |
| AvPermissionSelect | _N/A_ | _N/A_ | |
| AvProviderSelect | ControlledProviderAutocomplete | ProviderAutocomplete | Specialized autocomplete for providers |
| AvRegionSelect | _N/A_ | _N/A_ | |
| AvUserSelect | _N/A_ | _N/A_ | |
| Upload | _N/A_ | FileSelector | Select files for upload, show upload progress |

## Form Examples

- Legacy form with \`@availity/react\`, \`formik\`, and \`yup\`
- Form with \`@availity/element\` uncontrolled components, \`formik\`, and \`yup\` (<ins>Not Recommended</ins>)
- Form with \`@availity/element\`, \`react-hook-form\`, \`yup\` and \`@hookform/resolvers/yup\`
- Form with \`@availity/element\` and \`react-hook-form\` using internal rules for validation


At the moment, @availity/element does not export a \`<Form />\` component.
Instead, use the native \`<form>\` element. You can then use
\`react-hook-form\`'s \`useForm\` hook to manage your form.

<br />

### Legacy form with \`@availity/react\`, \`formik\`, and \`yup\`

<details>
<summary>Code example</summary>

\`\`\`tsx
import React from 'react';
import { Form, Field, Radio, RadioGroup, SelectField } from '@availity/form';
import { Button } from 'reactstrap';

export const Form = () => {
  const ref = useRef();
  return (
    <Form
      onKeyDown={({ key }) => key === 'Escape' && onClose()}
      initialValues={{
        textField: "",
        selectField: undefined,
        radio: "",
      }}
      validationSchema={yup.object().shape({
        textField: yup
          .string()
          .max(200, 'Text Field cannot exceed 200 characters.')
          .required('This field is required.'),
        selectField: yup
          .string()
          .required('This Field is required.')
          .nullable(),
        radio: yup
          .string()
          .required('A selection is required'),
      })}
      {...formProps}
      onSubmit={(values) => sendValues(values)}
    >
      <RequiredKey/>
      <Field type="textarea" name="textField" label="Text Field" required/>
      <SelectField
        label="Select Field"
        name="selectField"
        required
        options={[{label: "Option 1", value: "1"}, {label: "Option 2", value: "2"}]}
      />
      <RadioGroup
        name="radio"
        label="Radio Group"
        inline
        required
      >
        <Radio label="Radio 1" value="1" />
        <Radio label="Radio 2" value="2" />
      </RadioGroup>
      <Button
        type="submit"
      >
        Submit
      </Button>
    </Form>
  );
};
\`\`\`
</details>
<br />

### Form with \`@availity/element\` uncontrolled components, \`formik\`, and \`yup\` (Not Recommended)

It does not save much time/effort reformatting to keep \`formik\` versus switching
over to \`react-hook-form\`, therefore we don't recommend this approach to migrate.

<details>
<summary>Code example</summary>

\`\`\`tsx
import React from 'react';
import * as yup from 'yup';
import { useFormikContext, Form, Formik, useFormik } from 'formik';
import {
  Box,
  Button,
  FormControl,
  FormHelperText,
  FormLabel,
  FormControlLabel,
  Radio,
  RadioGroup,
  RequiredKey,
  TextField,
  Autocomplete} from '@availity/element';

export const Form = () => (
  <Formik
    initialValues={{
      textField: "",
      selectField: undefined,
      radio: "",
    }}
    validationSchema={yup.object().shape({
      textField: yup
        .string()
        .max(200, 'Text Field cannot exceed 200 characters.')
        .required('This field is required.'),
      selectField: yup
        .string()
        .required('This Field is required.'),
      radio: yup
        .string()
        .required('A selection is required'),
    })}
    onSubmit={(values) => console.log(values)}
  >
    {formik => (
      <Box component={Form}>
        <RequiredKey/>
        <TextField
          name="textField"
          label="Textfield"
          multiline
          helperText={formik.touched.textField && formik.errors.textField ? formik.errors.textField : null}
          required
          value={formik.values.textField}
          error={formik.touched.textField && Boolean(formik.errors.textField)}
          onChange={formik.handleChange}
          onBlur={formik.handleBlur}
          margin="normal"
        />
        <Autocomplete
          name="selectField"
          onChange={(e, value) => {
            formik.setFieldValue("selectField", value !== null ? value.value : formik.initialValues.selectField)
          }}
          onBlur={formik.handleBlur}
          FieldProps={{
            margin:"normal",
            label: 'Select Field',
            placeholder: 'Value',
            required: true,
            error: formik.touched.selectField && Boolean(formik.errors.selectField),
            helperText: formik.touched.selectField && formik.errors.selectField,
          }}
          options={[{label:"Option 1", value: "1"}, {label:"Option 2", value: "2"}]}
          value={formik.values.selectField}
        />
        <FormControl
          required
          margin="normal"
          sx={{mt: 2}}
          error={formik.touched.radio && Boolean(formik.errors.radio)}
        >
          <FormLabel id="radio-label" component="div">Radio 1</FormLabel>
          <RadioGroup
            name="radio"
            aria-labelledby="radio-label"
            row
            value={formik.values.radio}
            onChange={formik.handleChange}
            onBlur={formik.handleBlur}
          >
            <FormControlLabel control={<Radio/>} label="Radio 1" value="1" />
            <FormControlLabel control={<Radio/>} label="Radio 2" value="2" />
          </RadioGroup>
          {formik.touched.radio && Boolean(formik.errors.radio) ?
            <FormHelperText id="radio-helperText">{formik.errors.radio}</FormHelperText>
            : null
          }
        </FormControl>
        <Button
          type="submit"
        >
          Submit
        </Button>
        <Results/>
      </Box>
    )}
  </Formik>
);
\`\`\`
</details>

<!--
### Form with \`@availity/element\`, \`yup\` and \`@hookform/resolvers/yup\`

<details>
<summary>Code example</summary>

\`\`\`tsx
import type { Meta, StoryObj } from '@storybook/react-vite';
import dayjs from 'dayjs';
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';
import {
  ControlledTextField,
  ControlledAutocomplete,
  ControlledRadioGroup,
  ControlledDatepicker,
  FormControlLabel,
  FormProvider,
  LoadingButton,
  Radio,
  RequiredKey,
  SubmitHandler,
  useForm
} from '@availity/element';

export const Form = () => {
  const schema = yup.object({
    textField: yup
      .string()
      .max(200, 'Text Field cannot exceed 200 characters.')
      .required('This field is required.'),
    selectField: yup
      .string()
      .required('This Field is required.')
      .nullable(),
    datePicker: yup
      .mixed<dayjs.Dayjs>()
      .required('This Field is required.')
      .nullable(),
    radio: yup
      .string()
      .required('A selection is required'),
  });

  type FormInputsType = yup.InferType<typeof schema>;

  const onSubmit: SubmitHandler<FormInputsType> = (data) => console.log(data)/n
  const methods = useForm({
    defaultValues: {
      textField: "",
      selectField: undefined,
      datePicker: undefined,
      radio: "",
    },
    mode: 'onBlur',
    resolver: yupResolver(schema)
  });

  return (
    <FormProvider {...methods}>
      <form onSubmit={methods.handleSubmit(onSubmit)}>
        <RequiredKey />
        <ControlledTextField
          name="textField"
          label="Textfield"
          margin="normal"
          fullWidth
          helperText='Max 200 characters'
          required
        />
        <ControlledAutocomplete
          name="selectField"
          FieldProps={{
            margin:"normal",
            label: 'Select Field',
            placeholder: 'Value',
            required: true,
          }}
          options={dropdownOptions}
        />
        <ControlledDatepicker
          name="datePicker"
          FieldProps={{
            label: "Date",
            margin: "normal",
            required: true,
          }}
        />
        <ControlledRadioGroup name="radio" label="Radio Group" row aria-required required>
          <FormControlLabel control={<Radio />} value="1" label="Option 1" />
          <FormControlLabel control={<Radio />} value="2" label="Option 2" />
        </ControlledRadioGroup>
        <LoadingButton loading={methods?.formState?.isSubmitting} type="submit" >
          Submit
        </LoadingButton>
      </form>
    </FormProvider>
  )
}
\`\`\`
</details>

You can find more working examples of react-hook-form [here](/docs/sample-layouts-form--docs). -->

<!--
### Form with \`@availity/element\`, \`react-hook-form\`, and \`react-hook-form\` Internal Rules

<details>
<summary>Code example</summary>

\`\`\`tsx
import { useForm, SubmitHandler, Controller } from 'react-hook-form';
import { Autocomplete, Button, FormControl, FormControlLabel, FormHelperText, FormLabel, Paper, Radio, RadioGroup, RequiredKey, TextField } from '@availity/element';

export const Form = () => {
  const {
      register,
      handleSubmit,
      formState: { errors },
      control,
      reset,
      getValues,
    } = useForm({defaultValues: { textField: "", selectField: "", radio: ""}});
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <RequiredKey />
      <TextField
        label="Textfield"
        margin="normal"
        fullWidth
        {...register('textField', {
          required: 'This field is required',
          maxLength: { value: 200, message: 'This field must not exceed 200 characters'}})}
        required
        error={!!errors.textField}
        helperText={errors.textField?.message || 'Max 200 characters'}
      />
      <Controller
        control={control}
        name="selectField"
        rules={{ required: 'This field is required' }}
        render={({ field: { onChange, value, onBlur } }) => {
          return (
            <Autocomplete
              onChange={(event, value, reason) => {
                if (reason === 'clear') {
                  onChange(null);
                }
                onChange(value);
              }}
              onBlur={onBlur}
              FieldProps={{
                margin:"normal",
                label: 'Select Field',
                placeholder: 'Value',
                required: true,
                error: !!errors.selectField?.message,
                helperText: errors.selectField?.message,
              }}
              options={dropdownOptions}
              value={value || null}
            />
          );
        }}
      />
      <FormControl margin="normal" error={!!errors.radio} required>
        <FormLabel id="radio-label" component="div">
          Radio Group
        </FormLabel>
        <Controller
          control={control}
          name="radio"
          rules={{ required: 'This field is required' }}
          render={({ field }) => (
            <RadioGroup aria-labelledby="radio-label" row {...field} aria-required>
              <FormControlLabel control={<Radio />} value="1" label="Option 1" />
              <FormControlLabel control={<Radio />} value="2" label="Option 2" />
            </RadioGroup>
          )}
        />
        {errors.radio ? <FormHelperText id="radio-helper-text">{errors.radio?.message}</FormHelperText> : null }
      </FormControl>
      <LoadingButton loading={loading} type="submit" >
        Submit
      </LoadingButton>
    </form>
  )
}
\`\`\`
</details> -->
`,An={title:"BS4 Migration/Form Migration",tags:["autodocs"],parameters:{docs:{description:{component:`${Rt}`},source:{state:!0}}}},Ye=["Bulbasaur","Squirtle","Charmander"],E={render:()=>{var n;const i=Ke({textField:V().max(200,"Text Field cannot exceed 200 characters.").required("This field is required."),selectField:V().required("This Field is required.").nullable(),datePicker:Be().required("This Field is required.").nullable(),radio:V().required("A selection is required")}),e=o=>{var s;return!((s=i.describe().fields[o])!=null&&s.optional)||void 0},t=o=>console.log(o),r=Ae({defaultValues:{textField:"",selectField:void 0,datePicker:void 0,radio:""},mode:"onBlur",resolver:Et(i)});return f.jsx(Ee,{...r,children:f.jsxs("form",{onSubmit:r.handleSubmit(t),children:[f.jsx(Le,{}),f.jsx(je,{name:"textField",label:"Textfield",margin:"normal",fullWidth:!0,helperText:"Max 200 characters",required:e("textField")}),f.jsx(De,{name:"selectField",FieldProps:{margin:"normal",label:"Select Field",placeholder:"Value",required:e("selectField")},options:Ye}),f.jsx(Pe,{name:"datePicker",FieldProps:{label:"Date",margin:"normal",required:e("datePicker")}}),f.jsxs(Ne,{name:"radio",label:"Radio Group",row:!0,"aria-required":!0,required:e("radio"),children:[f.jsx(z,{control:f.jsx(M,{}),value:"1",label:"Option 1"}),f.jsx(z,{control:f.jsx(M,{}),value:"2",label:"Option 2"})]}),f.jsx(Re,{loading:(n=r==null?void 0:r.formState)==null?void 0:n.isSubmitting,type:"submit",sx:{mt:2},children:"Submit"})]})})}},R={render:()=>{var t;const i=Ae({defaultValues:{textField:"",selectField:null,datePicker:null,radio:""}}),e=r=>console.log(r);return f.jsx(Ee,{...i,children:f.jsxs("form",{onSubmit:i.handleSubmit(e),children:[f.jsx(Le,{}),f.jsx(je,{name:"textField",label:"Textfield",margin:"normal",fullWidth:!0,required:!0,rules:{required:"This field is required",maxLength:{value:200,message:"This field must not exceed 200 characters"}},helperText:"Max 200 characters"}),f.jsx(De,{name:"selectField",rules:{required:"This field is required"},FieldProps:{margin:"normal",label:"Select Field",placeholder:"Value",required:!0},options:Ye}),f.jsx(Pe,{name:"datePicker",rules:{required:"This field is required"},FieldProps:{label:"Date",margin:"normal",required:!0}}),f.jsxs(Ne,{name:"radio",label:"Radio Group",row:!0,"aria-required":!0,required:!0,rules:{required:"This field is required"},children:[f.jsx(z,{control:f.jsx(M,{}),value:"1",label:"Option 1"}),f.jsx(z,{control:f.jsx(M,{}),value:"2",label:"Option 2"})]}),f.jsx(Re,{loading:(t=i==null?void 0:i.formState)==null?void 0:t.isSubmitting,type:"submit",sx:{mt:2},children:"Submit"})]})})}},j={render:()=>f.jsxs(f.Fragment,{children:[f.jsx(ae,{margin:"normal",value:"value",label:"Read Only",id:"read-only",fullWidth:!0,slotProps:{input:{readOnly:!0}},helperText:"Read-only state should be used for values that cannot be changed by the user, but are still significant. i.e. when the value is populated based on another field value."}),f.jsx(ae,{margin:"normal",value:"value",label:"Disabled",id:"disabled",fullWidth:!0,disabled:!0,helperText:"Disabled state should be used for values that are not applicable currently, but could be enabled in a different state."})]})};var be,xe,ye,ge,Fe;E.parameters={...E.parameters,docs:{...(be=E.parameters)==null?void 0:be.docs,source:{originalSource:`{
  render: () => {
    const schema = yup.object({
      textField: yup.string().max(200, 'Text Field cannot exceed 200 characters.').required('This field is required.'),
      selectField: yup.string().required('This Field is required.').nullable(),
      datePicker: yup.mixed<dayjs.Dayjs>().required('This Field is required.').nullable(),
      radio: yup.string().required('A selection is required')
    });
    const isRequired = (name: string) => {
      return !(schema.describe().fields[name] as yup.SchemaDescription)?.optional || undefined;
    };
    type FormInputsType = yup.InferType<typeof schema>;
    const onSubmit: SubmitHandler<FormInputsType> = data => console.log(data);
    const methods = useForm({
      defaultValues: {
        textField: "",
        selectField: undefined,
        datePicker: undefined,
        radio: ""
      },
      mode: 'onBlur',
      resolver: yupResolver(schema)
    });
    return <FormProvider {...methods}>
        <form onSubmit={methods.handleSubmit(onSubmit)}>
          <RequiredKey />
          <ControlledTextField name="textField" label="Textfield" margin="normal" fullWidth helperText='Max 200 characters' required={isRequired('textField')} />
          <ControlledAutocomplete name="selectField" FieldProps={{
          margin: "normal",
          label: 'Select Field',
          placeholder: 'Value',
          required: isRequired('selectField')
        }} options={dropdownOptions} />
          <ControlledDatepicker name="datePicker" FieldProps={{
          label: "Date",
          margin: "normal",
          required: isRequired('datePicker')
        }} />
          <ControlledRadioGroup name="radio" label="Radio Group" row aria-required required={isRequired('radio')}>
            <FormControlLabel control={<Radio />} value="1" label="Option 1" />
            <FormControlLabel control={<Radio />} value="2" label="Option 2" />
          </ControlledRadioGroup>
          <LoadingButton loading={methods?.formState?.isSubmitting} type="submit" sx={{
          mt: 2
        }}>
            Submit
          </LoadingButton>
        </form>
      </FormProvider>;
  }
}`,...(ye=(xe=E.parameters)==null?void 0:xe.docs)==null?void 0:ye.source},description:{story:"Form with `@availity/element` controlled form components, `yup`, and `@hookform/resolvers/yup`",...(Fe=(ge=E.parameters)==null?void 0:ge.docs)==null?void 0:Fe.description}}};var ve,ke,we,Se,Te;R.parameters={...R.parameters,docs:{...(ve=R.parameters)==null?void 0:ve.docs,source:{originalSource:`{
  render: () => {
    const methods = useForm({
      defaultValues: {
        textField: '',
        selectField: null,
        datePicker: null,
        radio: ''
      }
    });
    const onSubmit = (data: any) => console.log(data);
    return <FormProvider {...methods}>
        <form onSubmit={methods.handleSubmit(onSubmit)}>
          <RequiredKey />
          <ControlledTextField name="textField" label="Textfield" margin="normal" fullWidth required rules={{
          required: 'This field is required',
          maxLength: {
            value: 200,
            message: 'This field must not exceed 200 characters'
          }
        }} helperText='Max 200 characters' />
          <ControlledAutocomplete name="selectField" rules={{
          required: 'This field is required'
        }} FieldProps={{
          margin: "normal",
          label: 'Select Field',
          placeholder: 'Value',
          required: true
        }} options={dropdownOptions} />
          <ControlledDatepicker name="datePicker" rules={{
          required: 'This field is required'
        }} FieldProps={{
          label: "Date",
          margin: "normal",
          required: true
        }} />
          <ControlledRadioGroup name="radio" label="Radio Group" row aria-required required rules={{
          required: 'This field is required'
        }}>
            <FormControlLabel control={<Radio />} value="1" label="Option 1" />
            <FormControlLabel control={<Radio />} value="2" label="Option 2" />
          </ControlledRadioGroup>
          <LoadingButton loading={methods?.formState?.isSubmitting} type="submit" sx={{
          mt: 2
        }}>
            Submit
          </LoadingButton>
        </form>
      </FormProvider>;
  }
}`,...(we=(ke=R.parameters)==null?void 0:ke.docs)==null?void 0:we.source},description:{story:"Form with `@availity/element` controlled form components using internal rules for validation.\n\nUseful for smaller forms where writing a full schema could be cumbersome.",...(Te=(Se=R.parameters)==null?void 0:Se.docs)==null?void 0:Te.description}}};var _e,Oe,Ce,$e,qe;j.parameters={...j.parameters,docs:{...(_e=j.parameters)==null?void 0:_e.docs,source:{originalSource:`{
  render: () => <>
      <TextField margin="normal" value="value" label="Read Only" id="read-only" fullWidth slotProps={{
      input: {
        readOnly: true
      }
    }} helperText="Read-only state should be used for values that cannot be changed by the user, but are still significant. i.e. when the value is populated based on another field value." />
      <TextField margin="normal" value="value" label="Disabled" id="disabled" fullWidth disabled helperText="Disabled state should be used for values that are not applicable currently, but could be enabled in a different state." />
    </>
}`,...(Ce=(Oe=j.parameters)==null?void 0:Oe.docs)==null?void 0:Ce.source},description:{story:"We are moving away from our extensive use of `disabled` fields in favor of `read-only` fields.\nThis is necessary for accessibility as `disabled` fields are not available to the keyboard/screenreader, so the filled in values cannot be seen.",...(qe=($e=j.parameters)==null?void 0:$e.docs)==null?void 0:qe.description}}};const En=["_YupValidation","_RHFRules","_DisabledFields"];export{j as _DisabledFields,R as _RHFRules,E as _YupValidation,En as __namedExportsOrder,An as default};
