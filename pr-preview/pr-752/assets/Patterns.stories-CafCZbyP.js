import{j as e}from"./jsx-runtime-BTJTZTIL.js";import{r as G}from"./index-BgYLq7fD.js";import{B as y,I as te}from"./index-k9OtkSpc.js";import{C as le}from"./index-zOfo1cSu.js";import{F as oe,i as ae,j as ie,a as ne}from"./index-YXU10wut.js";import{c as se,k as ce,C as me}from"./index-CmMPo3bx.js";import{B as x,G as p,S as z}from"./index-DmY_4rvh.js";import{M as E}from"./index-BXajI0Rm.js";import{P as ue}from"./index-Bd2OKRRh.js";import{T as pe}from"./index-CiN-zn2K.js";import{T as B}from"./index-ClMemn8c.js";import{u as H,C as S}from"./index.esm-Cdw3oWqD.js";import{T as de,a as he}from"./TablePagination-DYDxEu5A.js";import{T as M,a as be}from"./TableRow-D5lAztty.js";import{T as a}from"./TableCell-BcTZw5PM.js";import{T as fe}from"./TableContainer-ClzDj8v-.js";import"./TableSortLabel-BJpxS7DP.js";import{F as ye}from"./FormControl-eNKWX08Y.js";import{I as R}from"./InputAdornment-D5eTYx4L.js";import{P as xe}from"./Popover-DNs0CrC2.js";import{F as ve}from"./RadioGroup-CGGGzwtq.js";import{L as Fe}from"./Link-rLN5tdDv.js";import"./index-ChsGqxH_.js";import"./_commonjsHelpers-D6-XlEtG.js";import"./Tooltip-Xh9QA514.js";import"./generateUtilityClass-GxznSYtt.js";import"./identifier-CHUoN9pF.js";import"./index-DyJdRKzS.js";import"./useTheme-BGaXYmwe.js";import"./DefaultPropsProvider-ArLX9SCD.js";import"./useTheme-CVByJb8R.js";import"./styled-FZfCzBz5.js";import"./memoTheme-BLrvrRyo.js";import"./useSlot-qvYlW2UV.js";import"./resolveComponentProps-XMphxBSb.js";import"./useForkRef-Dz4aGlyk.js";import"./generateUtilityClasses-aotQgNYZ.js";import"./useTimeout-iC_34LsC.js";import"./useEnhancedEffect-j2zQLnYm.js";import"./useControlled-DxC1uCGX.js";import"./useId-DIK8ekB4.js";import"./getReactElementRef-Df0xbma2.js";import"./Portal-DEVqEMA6.js";import"./utils-tFrEP9Vf.js";import"./objectWithoutPropertiesLoose-Dsqj8S3w.js";import"./TransitionGroupContext-BKlA24Pm.js";import"./index-Bxu_udwM.js";import"./index-DdXvKv-Q.js";import"./ownerDocument-DW-IO8s5.js";import"./useSlotProps-DT0tbkWv.js";import"./isFocusVisible-B8k4qzLc.js";import"./IconButton-BFylt634.js";import"./createSimplePaletteValueFilter-bm0fmN_7.js";import"./ButtonBase-DwAEbHIm.js";import"./emotion-react.browser.esm-DW5OmoQI.js";import"./CircularProgress-o1goEU37.js";import"./Button-DrYdciQ0.js";import"./LoadingButton-C6EjcQI6.js";import"./Chip-H5O1l7tv.js";import"./createSvgIcon-DK1T27V3.js";import"./SvgIcon-D3xe1wVB.js";import"./index-DJKl12U0.js";import"./faCheck-BUdkY9Qv.js";import"./Select-D8Pqa1Dd.js";import"./formControlState-Dq1zat_P.js";import"./useFormControl-t_-EwZHM.js";import"./Menu-BUIr0rCt.js";import"./Modal-BSor9Am9.js";import"./ownerWindow-HkKU3E4x.js";import"./Backdrop-DwIksyfj.js";import"./Fade-rL0rk9XF.js";import"./List-CN2yCDHK.js";import"./OutlinedInput-ClKDCKpR.js";import"./isHostComponent-DVu5iVWx.js";import"./index-Df15702_.js";import"./extendSxProp-BZnzVrgj.js";import"./debounce-Be36O1Ab.js";import"./FormControlLabel-NrRuXsuu.js";import"./Typography-geKghQyJ.js";import"./Switch-BMNMooHv.js";import"./SwitchBase-DpeF2ikX.js";import"./Box-BU2WakPM.js";import"./Divider-CE8hkX1u.js";import"./dividerClasses-Cy3VQ5Zc.js";import"./Stack-2ILcP_1D.js";import"./styled-CsKbBpC_.js";import"./useThemeProps-BNBLMFIr.js";import"./faCircleArrowRight-B14F5Piw.js";import"./faUser-D77uLSLS.js";import"./faSortDown-BIc1sKK4.js";import"./Grid2-BbvvmKhh.js";import"./isMuiElement-DiOAsJE6.js";import"./Container-DvcsWH8C.js";import"./MenuItem-B0sbJV79.js";import"./listItemTextClasses-BE6nMJZB.js";import"./Paper-zGtC1N39.js";import"./TextField-Dbm3e8rv.js";import"./TableHead-oMlxqc4e.js";import"./TableCell-DT8dV3s1.js";import"./index-K0C69Pun.js";import"./KeyboardArrowRight-DGijcEGn.js";import"./PaginationItem-flpc0RTc.js";import"./Pagination-BT2C5VbO.js";import"./TableRow-CYkSGJKZ.js";import"./visuallyHidden-Dan1xhjv.js";import"./TableContainer-BQmYc0Cb.js";import"./TableSortLabel-DaBUob62.js";const gt={title:"Components/Table/Patterns",tags:["autodocs"],parameters:{docs:{description:{component:"UX approved patterns to accompany Table"}}}},Z=g=>e.jsxs(ue,{sx:{borderWidth:"1px",borderColor:"border.decoration",marginTop:2,borderBottom:"none"},children:[e.jsx(g,{}),e.jsx(fe,{children:e.jsxs(de,{children:[e.jsx(he,{children:e.jsxs(M,{children:[e.jsx(a,{children:"Column 1"}),e.jsx(a,{children:"Column 2"}),e.jsx(a,{children:"Column 3"}),e.jsx(a,{children:"Column 4"}),e.jsx(a,{children:"Column 5"}),e.jsx(a,{children:"Column 6"})]})}),e.jsx(be,{children:e.jsx(M,{children:e.jsx(a,{sx:{borderBottom:"none"}})})})]})})]}),v={render:(g,{globals:{theme:C}})=>e.jsx(a,{component:"div",variant:"header",size:C==="light"?"medium":"small",children:e.jsx(B,{component:"div",variant:"h6",children:"Table Title"})}),decorators:[Z]},F={render:(g,{globals:{theme:C}})=>{const X=[{searchbyValue:"column2",searchbyLabel:"Column 2",searchValue:"Payer 1"},{searchbyValue:"column5",searchbyLabel:"Column 5",searchValue:"Pending"}],T=[{label:"Column 1",value:"column1"},{label:"Column 2",value:"column2"},{label:"Column 3",value:"column3"}],J={searchbyValue:"column1",searchValue:""},[i,V]=G.useState(X),[L,I]=G.useState(null),k=!!L,w=k?"filter-popover":void 0,j=()=>{I(null)},K=r=>{I(r.currentTarget)},N=r=>{const t=i.findIndex(l=>l.searchbyValue===r.searchbyValue&&l.searchValue===r.searchValue);i.splice(t,1),V([...i])},A=r=>{const t=[...i,...r].sort((l,o)=>{const n=l.searchbyLabel.toUpperCase(),d=o.searchbyLabel.toUpperCase();return n<d?-1:n>d?1:0});V([...t])},{handleSubmit:Q,control:O}=H({defaultValues:J}),Y=r=>{var l;const t={...r,searchbyLabel:((l=T.find(o=>o.value===r.searchbyValue))==null?void 0:l.label)||""};!i.find(o=>o.searchbyValue===t.searchbyValue&&o.searchValue===t.searchValue)&&A([t])},ee=()=>{const r={column4:"",column5:"",column6:""},t=[{label:"Column 4",value:"column4"},{label:"Column 5",value:"column5"},{label:"Column 6",value:"column6"}],l=[{label:"Value 1",value:"value1"},{label:"Value 2",value:"value2"},{label:"Value 3",value:"value3"}],{handleSubmit:o,control:n,reset:d,formState:{errors:ge}}=H({defaultValues:r}),re=m=>{var h,b;const u=[];for(const[f,s]of Object.entries(m)){const P=s&&!i.find(c=>c.searchbyValue===f&&c.searchValue===s)&&{searchbyValue:f,searchbyLabel:((h=t.find(c=>c.value===f))==null?void 0:h.label)||"",searchValue:s,searchLabel:((b=l.find(c=>c.value===s))==null?void 0:b.label)||""};P&&u.push(P)}u&&A(u),j()};return e.jsx(x,{component:"form",id:"filter-form",onSubmit:o(re),onReset:()=>d(),children:e.jsxs(z,{direction:"column",spacing:2,children:[t.map(m=>e.jsx(S,{name:m.value,control:n,render:({field:{onChange:u,value:h},fieldState:{error:b},formState:f})=>e.jsx(pe,{label:m.label,error:!!b,value:h,onChange:u,select:!0,margin:"none",children:l.map(s=>e.jsx(E,{value:s.value,children:s.label},s.value))},m.value)})),e.jsxs(z,{direction:"row",spacing:2,children:[e.jsx(y,{type:"reset",color:"secondary",children:"Reset Filters"}),e.jsx(y,{type:"submit",color:"primary",children:"Apply Filters"})]})]})})};return e.jsxs(a,{component:"div",variant:"header",size:C==="light"?"medium":"small",children:[e.jsx(B,{component:"h3",variant:"h6",sx:{marginBottom:3},children:"Table Title"}),e.jsxs(x,{component:"form",id:"search-form",onSubmit:Q(Y),sx:{paddingBottom:2},children:[e.jsx(oe,{htmlFor:"searchbyValue",id:"searchbyValueLabel",children:"Search By"}),e.jsxs(p,{container:!0,spacing:1,sx:{flexWrap:"wrap"},children:[e.jsx(p,{children:e.jsx(S,{name:"searchbyValue",control:O,rules:{required:{value:!0,message:"This field is required"}},render:({field:{onChange:r,value:t,ref:l},fieldState:{error:o}})=>e.jsx(ae,{fullWidth:!1,error:!!o,value:t,onChange:r,inputRef:l,margin:"none",sx:{flexShrink:0},labelId:"searchbyValueLabel",children:T.map(n=>e.jsx(E,{value:n.value,children:n.label},n.value))})})}),e.jsx(p,{size:"grow",children:e.jsx(S,{name:"searchValue",control:O,rules:{required:{value:!0,message:"This field is required"}},render:({field:{onChange:r,value:t,ref:l},fieldState:{error:o}})=>e.jsxs(ye,{error:!!o,margin:"none",sx:{flexGrow:1},fullWidth:!0,children:[e.jsx(ie,{id:"search",value:t,onChange:r,inputRef:l,startAdornment:e.jsx(R,{position:"start",children:e.jsx(se,{})}),placeholder:"Search",fullWidth:!0}),e.jsx(ne,{children:o&&o.message})]})})}),e.jsx(p,{children:e.jsx(y,{type:"submit",color:"primary",size:"large",children:"Search"})}),e.jsx(p,{children:e.jsxs(y,{type:"button",color:"secondary","aria-controls":w||"",id:"filter-button",onClick:K,size:"large",children:[e.jsx(R,{position:"start",sx:{color:"inherit"},children:e.jsx(ce,{})}),"Filter"]})})]})]}),e.jsx(xe,{id:w,"aria-labelledby":"filter-header",open:k,anchorEl:L,onClose:j,anchorOrigin:{vertical:"bottom",horizontal:"right"},transformOrigin:{vertical:"top",horizontal:"right"},children:e.jsxs(x,{sx:{padding:2},children:[e.jsxs(x,{sx:{justifyContent:"space-between",display:"flex",paddingBottom:2},children:[e.jsx(B,{component:"h2",variant:"h6",id:"filter-header",children:"Filters"}),e.jsx(te,{title:"close",onClick:j,sx:{m:"-12px"},children:e.jsx(me,{fontSize:"small"})})]}),e.jsx(ee,{})]})}),e.jsxs(ve,{"aria-label":"filters",role:"group",row:!0,children:[i.map(r=>e.jsx(le,{label:`${r.searchbyLabel}: ${r.searchLabel||r.searchValue}`,onDelete:()=>N(r),sx:{mr:1,mb:1}},`${r.searchbyValue}-${r.searchValue.toString().replace(/[^A-Z0-9]+/gi,"_")}}`)),!!i.length&&e.jsx(Fe,{component:"button",typography:"body1",height:"26px",onClick:()=>{V([])},children:"Clear All Filters"})]})]})},decorators:[Z]};var W,_,q;v.parameters={...v.parameters,docs:{...(W=v.parameters)==null?void 0:W.docs,source:{originalSource:`{
  render: (args, {
    globals: {
      theme
    }
  }) => <TableCell component="div" variant="header" size={theme === 'light' ? 'medium' : 'small'}>
      <Typography component="div" variant="h6">
        Table Title
      </Typography>
    </TableCell>,
  decorators: [HeaderDecorator]
}`,...(q=(_=v.parameters)==null?void 0:_.docs)==null?void 0:q.source}}};var $,D,U;F.parameters={...F.parameters,docs:{...($=F.parameters)==null?void 0:$.docs,source:{originalSource:`{
  render: (args, {
    globals: {
      theme
    }
  }) => {
    type OptionType = {
      label: string;
      value: string;
    };
    type Filter = {
      searchbyValue: string;
      searchbyLabel: string;
      searchValue: string | number;
      searchLabel?: string;
    };
    const defaultFilters: Filter[] = [{
      searchbyValue: 'column2',
      searchbyLabel: 'Column 2',
      searchValue: 'Payer 1'
    }, {
      searchbyValue: 'column5',
      searchbyLabel: 'Column 5',
      searchValue: 'Pending'
    }];
    const searchByOptions = [{
      label: 'Column 1',
      value: 'column1'
    }, {
      label: 'Column 2',
      value: 'column2'
    }, {
      label: 'Column 3',
      value: 'column3'
    }];
    const defaultSearchByValues = {
      searchbyValue: 'column1',
      searchValue: ''
    };
    const [filters, setFilters] = useState<Array<Filter>>(defaultFilters);
    const [filterAnchorEl, setFilterAnchorEl] = useState<HTMLButtonElement | null>(null);
    const isFilterPopoverOpen = Boolean(filterAnchorEl);
    const filterPopoverId = isFilterPopoverOpen ? 'filter-popover' : undefined;
    const handlePopoverClose = () => {
      setFilterAnchorEl(null);
    };
    const handleFilterButtonClick = (event: React.MouseEvent<HTMLButtonElement>) => {
      setFilterAnchorEl(event.currentTarget);
    };
    const removeFilter = (filter: Filter) => {
      const index = filters.findIndex(item => item.searchbyValue === filter.searchbyValue && item.searchValue === filter.searchValue);
      filters.splice(index, 1);
      setFilters([...filters]);
    };
    const addFilters = (newFilters: Filter[]) => {
      const updatedFilters = [...filters, ...newFilters].sort((a, b) => {
        const nameA = a.searchbyLabel.toUpperCase();
        const nameB = b.searchbyLabel.toUpperCase();
        if (nameA < nameB) {
          return -1;
        }
        if (nameA > nameB) {
          return 1;
        }
        return 0;
      });
      setFilters([...updatedFilters]);
    };
    const {
      handleSubmit,
      control
    } = useForm<Filter>({
      defaultValues: defaultSearchByValues
    });
    const onSearchSubmit = (data: Omit<Filter, 'searchbyLabel'>) => {
      const newFilter = {
        ...data,
        searchbyLabel: searchByOptions.find(item => item.value === data.searchbyValue)?.label || ''
      };
      !filters.find(item => item.searchbyValue === newFilter.searchbyValue && item.searchValue === newFilter.searchValue) && addFilters([newFilter]);
    };
    const FilterForm = () => {
      type FilterForm = {
        column4?: string;
        column5?: string;
        column6?: string;
      };
      const defaultFilterFormValues = {
        column4: '',
        column5: '',
        column6: ''
      };
      const filterByOptions = [{
        label: 'Column 4',
        value: 'column4'
      }, {
        label: 'Column 5',
        value: 'column5'
      }, {
        label: 'Column 6',
        value: 'column6'
      }];
      const filterOptions = [{
        label: 'Value 1',
        value: 'value1'
      }, {
        label: 'Value 2',
        value: 'value2'
      }, {
        label: 'Value 3',
        value: 'value3'
      }];
      const {
        handleSubmit,
        control,
        reset,
        formState: {
          errors
        }
      } = useForm<FilterForm>({
        defaultValues: defaultFilterFormValues
      });
      const onSubmit = (data: FilterForm) => {
        const newFilters: Filter[] = [];
        for (const [key, value] of Object.entries(data)) {
          const newFilter = value && !filters.find(item => item.searchbyValue === key && item.searchValue === value) && {
            searchbyValue: key,
            searchbyLabel: filterByOptions.find(item => item.value === key)?.label || '',
            searchValue: value,
            searchLabel: filterOptions.find(item => item.value === value)?.label || ''
          };
          newFilter && newFilters.push(newFilter);
        }
        newFilters && addFilters(newFilters);
        handlePopoverClose();
      };
      return <Box component="form" id="filter-form" onSubmit={handleSubmit(onSubmit)} onReset={() => reset()}>
          <Stack direction="column" spacing={2}>
            {filterByOptions.map((filterby: OptionType) => <Controller name={filterby.value as keyof typeof FilterForm} control={control} render={({
            field: {
              onChange,
              value
            },
            fieldState: {
              error
            },
            formState
          }) => <TextField key={filterby.value} label={filterby.label} error={!!error} value={value} onChange={onChange} select margin="none">
                    {filterOptions.map((option: OptionType) => <MenuItem key={option.value} value={option.value}>
                        {option.label}
                      </MenuItem>)}
                  </TextField>} />)}
            <Stack direction="row" spacing={2}>
              <Button type="reset" color="secondary">
                Reset Filters
              </Button>
              <Button type="submit" color="primary">
                Apply Filters
              </Button>
            </Stack>
          </Stack>
        </Box>;
    };
    return <TableCell component="div" variant="header" size={theme === 'light' ? 'medium' : 'small'}>
        <Typography component="h3" variant="h6" sx={{
        marginBottom: 3
      }}>
          Table Title
        </Typography>
        <Box component="form" id="search-form" onSubmit={handleSubmit(onSearchSubmit)} sx={{
        paddingBottom: 2
      }}>
          <FormLabel htmlFor="searchbyValue" id="searchbyValueLabel">
            Search By
          </FormLabel>
          <Grid container spacing={1} sx={{
          flexWrap: 'wrap'
        }}>
            <Grid>
              <Controller name="searchbyValue" control={control} rules={{
              required: {
                value: true,
                message: 'This field is required'
              }
            }} render={({
              field: {
                onChange,
                value,
                ref
              },
              fieldState: {
                error
              }
            }) => <Select fullWidth={false} error={!!error} value={value} onChange={onChange} inputRef={ref} margin="none" sx={{
              flexShrink: 0
            }} labelId="searchbyValueLabel">
                    {searchByOptions.map((option: OptionType) => <MenuItem key={option.value} value={option.value}>
                        {option.label}
                      </MenuItem>)}
                  </Select>} />
            </Grid>
            <Grid size="grow">
              <Controller name="searchValue" control={control} rules={{
              required: {
                value: true,
                message: 'This field is required'
              }
            }} render={({
              field: {
                onChange,
                value,
                ref
              },
              fieldState: {
                error
              }
            }) => <FormControl error={!!error} margin="none" sx={{
              flexGrow: 1
            }} fullWidth>
                    <Input id="search" value={value} onChange={onChange} inputRef={ref} startAdornment={<InputAdornment position="start">
                          <SearchIcon />
                        </InputAdornment>} placeholder="Search" fullWidth />
                    <FormHelperText>{error && error.message}</FormHelperText>
                  </FormControl>} />
            </Grid>
            <Grid>
              <Button type="submit" color="primary" size="large">
                Search
              </Button>
            </Grid>
            <Grid>
              <Button type="button" color="secondary" aria-controls={filterPopoverId || ''} id="filter-button" onClick={handleFilterButtonClick} size="large">
                <InputAdornment position="start" sx={{
                color: 'inherit'
              }}>
                  <FilterIcon />
                </InputAdornment>
                Filter
              </Button>
            </Grid>
          </Grid>
        </Box>
        <Popover id={filterPopoverId} aria-labelledby="filter-header" open={isFilterPopoverOpen} anchorEl={filterAnchorEl} onClose={handlePopoverClose} anchorOrigin={{
        vertical: 'bottom',
        horizontal: 'right'
      }} transformOrigin={{
        vertical: 'top',
        horizontal: 'right'
      }}>
          <Box sx={{
          padding: 2
        }}>
            <Box sx={{
            justifyContent: 'space-between',
            display: 'flex',
            paddingBottom: 2
          }}>
              <Typography component="h2" variant="h6" id="filter-header">
                Filters
              </Typography>
              <IconButton title="close" onClick={handlePopoverClose} sx={{
              m: '-12px'
            }}>
                <CloseIcon fontSize="small" />
              </IconButton>
            </Box>
            <FilterForm />
          </Box>
        </Popover>
        <FormGroup aria-label="filters" role="group" row>
          {filters.map(filter => <Chip key={\`\${filter.searchbyValue}-\${filter.searchValue.toString().replace(/[^A-Z0-9]+/gi, '_')}}\`} label={\`\${filter.searchbyLabel}: \${filter.searchLabel || filter.searchValue}\`} onDelete={() => removeFilter(filter)} sx={{
          mr: 1,
          mb: 1
        }} />)}
          {!!filters.length && <MuiLink component="button" typography="body1" height="26px" onClick={() => {
          setFilters([]);
        }}>
              Clear All Filters
            </MuiLink>}
        </FormGroup>
      </TableCell>;
  },
  decorators: [HeaderDecorator]
}`,...(U=(D=F.parameters)==null?void 0:D.docs)==null?void 0:U.source}}};const Ct=["_Header","_HeaderWithSearchAndFilter"];export{v as _Header,F as _HeaderWithSearchAndFilter,Ct as __namedExportsOrder,gt as default};
