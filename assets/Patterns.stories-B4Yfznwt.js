import{j as e}from"./jsx-runtime-D_zvdyIk.js";import{r as G}from"./index-BSuoOqEd.js";import{B as y,I as te}from"./index-DS7md1Ks.js";import{C as oe}from"./index-CzBWDcEW.js";import{F as le,g as ae,h as ie,a as ne}from"./index-COQJUt6i.js";import{c as se,k as me,C as ce}from"./index-BgHLshU-.js";import{B as x,G as p,S as z}from"./index-DWvMPRyT.js";import{M as E}from"./index-D8d9z6Lv.js";import{P as ue}from"./index-D24HNVk6.js";import{T as pe}from"./index-BOLVSG5X.js";import{T as B}from"./index-7dkkVNWZ.js";import{u as H,C as j}from"./index.esm-OZwL_toQ.js";import{T as a}from"./TableCell-CyFtU58z.js";import{T as de}from"./TableContainer-C9bvwUME.js";import{T as he}from"./Table-BVC8iNKX.js";import{T as be}from"./TableHead-DmK4owvJ.js";import{T as M}from"./TableRow-D9dwicER.js";import{T as fe}from"./TableBody-DCllLK_F.js";import{F as ye}from"./FormControl-Drbi3xw9.js";import{I as R}from"./InputAdornment-ClwDxA6I.js";import{P as xe}from"./Popover-BxuONtmd.js";import{F as ve}from"./FormGroup-yFjuLh-9.js";import{L as Fe}from"./Link-CWKQpknP.js";import"./_commonjsHelpers-D6-XlEtG.js";import"./Tooltip-bMNvQkmf.js";import"./identifier-DhnHujDJ.js";import"./index-bqlmQ0VS.js";import"./useTheme-DG5qVMsu.js";import"./DefaultPropsProvider-B1sWsgx2.js";import"./useTheme-C_c7PR3o.js";import"./styled-9znMky1q.js";import"./memoTheme-BwIkkReu.js";import"./useSlot-jI6_c_PV.js";import"./mergeSlotProps-C8ahzxnq.js";import"./isHostComponent-DVu5iVWx.js";import"./useForkRef-BIkqQIqh.js";import"./generateUtilityClasses-DDbjFgb8.js";import"./generateUtilityClass-BtcU_pBl.js";import"./useTimeout-B9dULhq6.js";import"./useControlled-DUUijreW.js";import"./useId-kjFOwFR3.js";import"./useEventCallback-Dvy07Fv6.js";import"./useEnhancedEffect-CIAiDanS.js";import"./getReactElementRef-B8liFQVS.js";import"./Portal-BleVqemi.js";import"./utils-DuVTnmV7.js";import"./TransitionGroupContext-CcytU7uK.js";import"./index-CRBziY_1.js";import"./index-CCz_6dyq.js";import"./ownerDocument-DW-IO8s5.js";import"./useSlotProps-BphRKsXg.js";import"./isFocusVisible-B8k4qzLc.js";import"./IconButton-aAtY6dbQ.js";import"./createSimplePaletteValueFilter-bm0fmN_7.js";import"./ButtonBase-AdAh9sBA.js";import"./emotion-react.browser.esm-CVJjYY2z.js";import"./CircularProgress-I3IM84c9.js";import"./Button-DMnfP4ih.js";import"./Chip-D0HJqAnB.js";import"./createSvgIcon-DjY4rWdK.js";import"./SvgIcon-enpUMgPP.js";import"./index-DJKl12U0.js";import"./faCheck-BUdkY9Qv.js";import"./FormLabel-BjKtkMG2.js";import"./formControlState-Dq1zat_P.js";import"./useFormControl-BP1ipPfY.js";import"./OutlinedInput-D6BW5ZNV.js";import"./index-DtRw77fL.js";import"./extendSxProp-plByhdXY.js";import"./utils-DoM3o7-Q.js";import"./ownerWindow-HkKU3E4x.js";import"./debounce-Be36O1Ab.js";import"./Select-zHj_PMX3.js";import"./Menu-Zm6-FwvC.js";import"./Modal-DRFlzA1R.js";import"./createChainedFunction-BO_9K8Jh.js";import"./Backdrop-B4Fx8sqp.js";import"./Fade-BMGLcTA9.js";import"./List-CmPLZKsv.js";import"./FormHelperText-C0N0yP7T.js";import"./FormControlLabel-Bg8bewgW.js";import"./Typography-CHtEfMke.js";import"./Switch-BQOh7xoK.js";import"./SwitchBase-D9HE_1I9.js";import"./RadioGroup-BALX6oMS.js";import"./Radio-BoswAQMN.js";import"./Box-BAprLmuU.js";import"./Divider-DtIvDB1e.js";import"./dividerClasses-CxQzuCbE.js";import"./Stack-C-7_RWLD.js";import"./styled-BN1MHGNr.js";import"./useThemeProps-DxTj-Mj7.js";import"./faCircleArrowRight-DSzUu1Qy.js";import"./faUser-D77uLSLS.js";import"./Grid-BrQtrDmH.js";import"./isMuiElement-CsRUsG_W.js";import"./Container-BRT0GL3j.js";import"./MenuItem-pDWsesgW.js";import"./listItemIconClasses-CyGEUV5Q.js";import"./listItemTextClasses-CiRxluPw.js";import"./Paper-BZZ0Jx2l.js";import"./TextField-Ct0ITBJk.js";import"./TableCell-CQrLN2wf.js";import"./visuallyHidden-Dan1xhjv.js";import"./TableContainer-CGhqpwL2.js";import"./Table-CFcaDVkG.js";import"./TableHead-DH-CAZNz.js";import"./TableRow-BBryrBZE.js";import"./TableBody-B1re9SC8.js";import"./mergeSlotProps-1djKqk8T.js";const St={title:"Components/Table/Patterns",tags:["autodocs"],parameters:{docs:{description:{component:"UX approved patterns to accompany Table"}}}},Z=g=>e.jsxs(ue,{sx:{borderWidth:"1px",borderColor:"border.decoration",marginTop:2,borderBottom:"none"},children:[e.jsx(g,{}),e.jsx(de,{children:e.jsxs(he,{children:[e.jsx(be,{children:e.jsxs(M,{children:[e.jsx(a,{children:"Column 1"}),e.jsx(a,{children:"Column 2"}),e.jsx(a,{children:"Column 3"}),e.jsx(a,{children:"Column 4"}),e.jsx(a,{children:"Column 5"}),e.jsx(a,{children:"Column 6"})]})}),e.jsx(fe,{children:e.jsx(M,{children:e.jsx(a,{sx:{borderBottom:"none"}})})})]})})]}),v={render:(g,{globals:{theme:C}})=>e.jsx(a,{component:"div",variant:"header",size:C==="light"?"medium":"small",children:e.jsx(B,{component:"div",variant:"h6",children:"Table Title"})}),decorators:[Z]},F={render:(g,{globals:{theme:C}})=>{const X=[{searchbyValue:"column2",searchbyLabel:"Column 2",searchValue:"Payer 1"},{searchbyValue:"column5",searchbyLabel:"Column 5",searchValue:"Pending"}],T=[{label:"Column 1",value:"column1"},{label:"Column 2",value:"column2"},{label:"Column 3",value:"column3"}],J={searchbyValue:"column1",searchValue:""},[i,V]=G.useState(X),[L,I]=G.useState(null),k=!!L,w=k?"filter-popover":void 0,S=()=>{I(null)},K=r=>{I(r.currentTarget)},N=r=>{const t=i.findIndex(o=>o.searchbyValue===r.searchbyValue&&o.searchValue===r.searchValue);i.splice(t,1),V([...i])},A=r=>{const t=[...i,...r].sort((o,l)=>{const n=o.searchbyLabel.toUpperCase(),d=l.searchbyLabel.toUpperCase();return n<d?-1:n>d?1:0});V([...t])},{handleSubmit:Q,control:O}=H({defaultValues:J}),Y=r=>{var o;const t={...r,searchbyLabel:((o=T.find(l=>l.value===r.searchbyValue))==null?void 0:o.label)||""};!i.find(l=>l.searchbyValue===t.searchbyValue&&l.searchValue===t.searchValue)&&A([t])},ee=()=>{const r={column4:"",column5:"",column6:""},t=[{label:"Column 4",value:"column4"},{label:"Column 5",value:"column5"},{label:"Column 6",value:"column6"}],o=[{label:"Value 1",value:"value1"},{label:"Value 2",value:"value2"},{label:"Value 3",value:"value3"}],{handleSubmit:l,control:n,reset:d,formState:{errors:ge}}=H({defaultValues:r}),re=c=>{var h,b;const u=[];for(const[f,s]of Object.entries(c)){const P=s&&!i.find(m=>m.searchbyValue===f&&m.searchValue===s)&&{searchbyValue:f,searchbyLabel:((h=t.find(m=>m.value===f))==null?void 0:h.label)||"",searchValue:s,searchLabel:((b=o.find(m=>m.value===s))==null?void 0:b.label)||""};P&&u.push(P)}u&&A(u),S()};return e.jsx(x,{component:"form",id:"filter-form",onSubmit:l(re),onReset:()=>d(),children:e.jsxs(z,{direction:"column",spacing:2,children:[t.map(c=>e.jsx(j,{name:c.value,control:n,render:({field:{onChange:u,value:h},fieldState:{error:b},formState:f})=>e.jsx(pe,{label:c.label,error:!!b,value:h,onChange:u,select:!0,margin:"none",children:o.map(s=>e.jsx(E,{value:s.value,children:s.label},s.value))},c.value)})),e.jsxs(z,{direction:"row",spacing:2,children:[e.jsx(y,{type:"reset",color:"secondary",children:"Reset Filters"}),e.jsx(y,{type:"submit",color:"primary",children:"Apply Filters"})]})]})})};return e.jsxs(a,{component:"div",variant:"header",size:C==="light"?"medium":"small",children:[e.jsx(B,{component:"h3",variant:"h6",sx:{marginBottom:3},children:"Table Title"}),e.jsxs(x,{component:"form",id:"search-form",onSubmit:Q(Y),sx:{paddingBottom:2},children:[e.jsx(le,{htmlFor:"searchbyValue",id:"searchbyValueLabel",children:"Search By"}),e.jsxs(p,{container:!0,spacing:1,sx:{flexWrap:"wrap"},children:[e.jsx(p,{children:e.jsx(j,{name:"searchbyValue",control:O,rules:{required:{value:!0,message:"This field is required"}},render:({field:{onChange:r,value:t,ref:o},fieldState:{error:l}})=>e.jsx(ae,{fullWidth:!1,error:!!l,value:t,onChange:r,inputRef:o,margin:"none",sx:{flexShrink:0},labelId:"searchbyValueLabel",children:T.map(n=>e.jsx(E,{value:n.value,children:n.label},n.value))})})}),e.jsx(p,{size:"grow",children:e.jsx(j,{name:"searchValue",control:O,rules:{required:{value:!0,message:"This field is required"}},render:({field:{onChange:r,value:t,ref:o},fieldState:{error:l}})=>e.jsxs(ye,{error:!!l,margin:"none",sx:{flexGrow:1},fullWidth:!0,children:[e.jsx(ie,{id:"search",value:t,onChange:r,inputRef:o,startAdornment:e.jsx(R,{position:"start",children:e.jsx(se,{})}),placeholder:"Search",fullWidth:!0}),e.jsx(ne,{children:l&&l.message})]})})}),e.jsx(p,{children:e.jsx(y,{type:"submit",color:"primary",size:"large",children:"Search"})}),e.jsx(p,{children:e.jsxs(y,{type:"button",color:"secondary","aria-controls":w||"",id:"filter-button",onClick:K,size:"large",children:[e.jsx(R,{position:"start",sx:{color:"inherit"},children:e.jsx(me,{})}),"Filter"]})})]})]}),e.jsx(xe,{id:w,"aria-labelledby":"filter-header",open:k,anchorEl:L,onClose:S,anchorOrigin:{vertical:"bottom",horizontal:"right"},transformOrigin:{vertical:"top",horizontal:"right"},children:e.jsxs(x,{sx:{padding:2},children:[e.jsxs(x,{sx:{justifyContent:"space-between",display:"flex",paddingBottom:2},children:[e.jsx(B,{component:"h2",variant:"h6",id:"filter-header",children:"Filters"}),e.jsx(te,{title:"close",onClick:S,sx:{m:"-12px"},children:e.jsx(ce,{fontSize:"small"})})]}),e.jsx(ee,{})]})}),e.jsxs(ve,{"aria-label":"filters",role:"group",row:!0,children:[i.map(r=>e.jsx(oe,{label:`${r.searchbyLabel}: ${r.searchLabel||r.searchValue}`,onDelete:()=>N(r),sx:{mr:1,mb:1}},`${r.searchbyValue}-${r.searchValue.toString().replace(/[^A-Z0-9]+/gi,"_")}}`)),!!i.length&&e.jsx(Fe,{component:"button",typography:"body1",height:"26px",onClick:()=>{V([])},children:"Clear All Filters"})]})]})},decorators:[Z]};var W,_,q;v.parameters={...v.parameters,docs:{...(W=v.parameters)==null?void 0:W.docs,source:{originalSource:`{
  render: (args, {
    globals: {
      theme
    }
  }) => <TableCell component="div" variant="header" size={theme === 'light' ? 'medium' : 'small'}>
      <Typography component="div" variant="h6">
        Table Title
      </Typography>
    </TableCell>,
  decorators: [HeaderDecorator]
}`,...(q=(_=v.parameters)==null?void 0:_.docs)==null?void 0:q.source}}};var $,D,U;F.parameters={...F.parameters,docs:{...($=F.parameters)==null?void 0:$.docs,source:{originalSource:`{
  render: (args, {
    globals: {
      theme
    }
  }) => {
    type OptionType = {
      label: string;
      value: string;
    };
    type Filter = {
      searchbyValue: string;
      searchbyLabel: string;
      searchValue: string | number;
      searchLabel?: string;
    };
    const defaultFilters: Filter[] = [{
      searchbyValue: 'column2',
      searchbyLabel: 'Column 2',
      searchValue: 'Payer 1'
    }, {
      searchbyValue: 'column5',
      searchbyLabel: 'Column 5',
      searchValue: 'Pending'
    }];
    const searchByOptions = [{
      label: 'Column 1',
      value: 'column1'
    }, {
      label: 'Column 2',
      value: 'column2'
    }, {
      label: 'Column 3',
      value: 'column3'
    }];
    const defaultSearchByValues = {
      searchbyValue: 'column1',
      searchValue: ''
    };
    const [filters, setFilters] = useState<Array<Filter>>(defaultFilters);
    const [filterAnchorEl, setFilterAnchorEl] = useState<HTMLButtonElement | null>(null);
    const isFilterPopoverOpen = Boolean(filterAnchorEl);
    const filterPopoverId = isFilterPopoverOpen ? 'filter-popover' : undefined;
    const handlePopoverClose = () => {
      setFilterAnchorEl(null);
    };
    const handleFilterButtonClick = (event: React.MouseEvent<HTMLButtonElement>) => {
      setFilterAnchorEl(event.currentTarget);
    };
    const removeFilter = (filter: Filter) => {
      const index = filters.findIndex(item => item.searchbyValue === filter.searchbyValue && item.searchValue === filter.searchValue);
      filters.splice(index, 1);
      setFilters([...filters]);
    };
    const addFilters = (newFilters: Filter[]) => {
      const updatedFilters = [...filters, ...newFilters].sort((a, b) => {
        const nameA = a.searchbyLabel.toUpperCase();
        const nameB = b.searchbyLabel.toUpperCase();
        if (nameA < nameB) {
          return -1;
        }
        if (nameA > nameB) {
          return 1;
        }
        return 0;
      });
      setFilters([...updatedFilters]);
    };
    const {
      handleSubmit,
      control
    } = useForm<Filter>({
      defaultValues: defaultSearchByValues
    });
    const onSearchSubmit = (data: Omit<Filter, 'searchbyLabel'>) => {
      const newFilter = {
        ...data,
        searchbyLabel: searchByOptions.find(item => item.value === data.searchbyValue)?.label || ''
      };
      !filters.find(item => item.searchbyValue === newFilter.searchbyValue && item.searchValue === newFilter.searchValue) && addFilters([newFilter]);
    };
    const FilterForm = () => {
      type FilterForm = {
        column4?: string;
        column5?: string;
        column6?: string;
      };
      const defaultFilterFormValues = {
        column4: '',
        column5: '',
        column6: ''
      };
      const filterByOptions = [{
        label: 'Column 4',
        value: 'column4'
      }, {
        label: 'Column 5',
        value: 'column5'
      }, {
        label: 'Column 6',
        value: 'column6'
      }];
      const filterOptions = [{
        label: 'Value 1',
        value: 'value1'
      }, {
        label: 'Value 2',
        value: 'value2'
      }, {
        label: 'Value 3',
        value: 'value3'
      }];
      const {
        handleSubmit,
        control,
        reset,
        formState: {
          errors
        }
      } = useForm<FilterForm>({
        defaultValues: defaultFilterFormValues
      });
      const onSubmit = (data: FilterForm) => {
        const newFilters: Filter[] = [];
        for (const [key, value] of Object.entries(data)) {
          const newFilter = value && !filters.find(item => item.searchbyValue === key && item.searchValue === value) && {
            searchbyValue: key,
            searchbyLabel: filterByOptions.find(item => item.value === key)?.label || '',
            searchValue: value,
            searchLabel: filterOptions.find(item => item.value === value)?.label || ''
          };
          newFilter && newFilters.push(newFilter);
        }
        newFilters && addFilters(newFilters);
        handlePopoverClose();
      };
      return <Box component="form" id="filter-form" onSubmit={handleSubmit(onSubmit)} onReset={() => reset()}>
          <Stack direction="column" spacing={2}>
            {filterByOptions.map((filterby: OptionType) => <Controller name={filterby.value as keyof typeof FilterForm} control={control} render={({
            field: {
              onChange,
              value
            },
            fieldState: {
              error
            },
            formState
          }) => <TextField key={filterby.value} label={filterby.label} error={!!error} value={value} onChange={onChange} select margin="none">
                    {filterOptions.map((option: OptionType) => <MenuItem key={option.value} value={option.value}>
                        {option.label}
                      </MenuItem>)}
                  </TextField>} />)}
            <Stack direction="row" spacing={2}>
              <Button type="reset" color="secondary">
                Reset Filters
              </Button>
              <Button type="submit" color="primary">
                Apply Filters
              </Button>
            </Stack>
          </Stack>
        </Box>;
    };
    return <TableCell component="div" variant="header" size={theme === 'light' ? 'medium' : 'small'}>
        <Typography component="h3" variant="h6" sx={{
        marginBottom: 3
      }}>
          Table Title
        </Typography>
        <Box component="form" id="search-form" onSubmit={handleSubmit(onSearchSubmit)} sx={{
        paddingBottom: 2
      }}>
          <FormLabel htmlFor="searchbyValue" id="searchbyValueLabel">
            Search By
          </FormLabel>
          <Grid container spacing={1} sx={{
          flexWrap: 'wrap'
        }}>
            <Grid>
              <Controller name="searchbyValue" control={control} rules={{
              required: {
                value: true,
                message: 'This field is required'
              }
            }} render={({
              field: {
                onChange,
                value,
                ref
              },
              fieldState: {
                error
              }
            }) => <Select fullWidth={false} error={!!error} value={value} onChange={onChange} inputRef={ref} margin="none" sx={{
              flexShrink: 0
            }} labelId="searchbyValueLabel">
                    {searchByOptions.map((option: OptionType) => <MenuItem key={option.value} value={option.value}>
                        {option.label}
                      </MenuItem>)}
                  </Select>} />
            </Grid>
            <Grid size="grow">
              <Controller name="searchValue" control={control} rules={{
              required: {
                value: true,
                message: 'This field is required'
              }
            }} render={({
              field: {
                onChange,
                value,
                ref
              },
              fieldState: {
                error
              }
            }) => <FormControl error={!!error} margin="none" sx={{
              flexGrow: 1
            }} fullWidth>
                    <Input id="search" value={value} onChange={onChange} inputRef={ref} startAdornment={<InputAdornment position="start">
                          <SearchIcon />
                        </InputAdornment>} placeholder="Search" fullWidth />
                    <FormHelperText>{error && error.message}</FormHelperText>
                  </FormControl>} />
            </Grid>
            <Grid>
              <Button type="submit" color="primary" size="large">
                Search
              </Button>
            </Grid>
            <Grid>
              <Button type="button" color="secondary" aria-controls={filterPopoverId || ''} id="filter-button" onClick={handleFilterButtonClick} size="large">
                <InputAdornment position="start" sx={{
                color: 'inherit'
              }}>
                  <FilterIcon />
                </InputAdornment>
                Filter
              </Button>
            </Grid>
          </Grid>
        </Box>
        <Popover id={filterPopoverId} aria-labelledby="filter-header" open={isFilterPopoverOpen} anchorEl={filterAnchorEl} onClose={handlePopoverClose} anchorOrigin={{
        vertical: 'bottom',
        horizontal: 'right'
      }} transformOrigin={{
        vertical: 'top',
        horizontal: 'right'
      }}>
          <Box sx={{
          padding: 2
        }}>
            <Box sx={{
            justifyContent: 'space-between',
            display: 'flex',
            paddingBottom: 2
          }}>
              <Typography component="h2" variant="h6" id="filter-header">
                Filters
              </Typography>
              <IconButton title="close" onClick={handlePopoverClose} sx={{
              m: '-12px'
            }}>
                <CloseIcon fontSize="small" />
              </IconButton>
            </Box>
            <FilterForm />
          </Box>
        </Popover>
        <FormGroup aria-label="filters" role="group" row>
          {filters.map(filter => <Chip key={\`\${filter.searchbyValue}-\${filter.searchValue.toString().replace(/[^A-Z0-9]+/gi, '_')}}\`} label={\`\${filter.searchbyLabel}: \${filter.searchLabel || filter.searchValue}\`} onDelete={() => removeFilter(filter)} sx={{
          mr: 1,
          mb: 1
        }} />)}
          {!!filters.length && <MuiLink component="button" typography="body1" height="26px" onClick={() => {
          setFilters([]);
        }}>
              Clear All Filters
            </MuiLink>}
        </FormGroup>
      </TableCell>;
  },
  decorators: [HeaderDecorator]
}`,...(U=(D=F.parameters)==null?void 0:D.docs)==null?void 0:U.source}}};const jt=["_Header","_HeaderWithSearchAndFilter"];export{v as _Header,F as _HeaderWithSearchAndFilter,jt as __namedExportsOrder,St as default};
